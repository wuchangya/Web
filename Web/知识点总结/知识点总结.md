# html+css

## 行内元素和块级元素

**==行内元素属性==**  **本身属性为display:inline的元素**

1、行内元素不独占一行，其他行内元素会依次排列在一行直到一行排列不下才会换行，宽度跟随元素的内容变化

2、行内元素无法设置宽高，可以设置line-height，margin上下无效，padding上下无效

3、行内元素内部**不能嵌套其他行内元素标签**

disply：inline

注：**==img和input==**比较特殊，可以改变宽和高、

**==块级元素==**  **本身属性为display:block的元素**

1.块级元素独占一行，宽度自动填满父元素的宽度

2.块元素可以设置width height属性

3、块元素margin和padding水平方向设置有效，垂直方向无效

4、块级元素可以包含行内元素和块级元素，行内元素不能包含块级元素

5、p标签中不能嵌套div标签

display：block

**==行内块元素==**

display ：inline-block

应用比较多

行内块元素和其他元素一行，可以设置元素的宽高。






**内联元素（行内元素）内联元素(inline element)**

 \* ==a== - 锚点

\* abbr - 缩写

\* acronym - 首字

\* b - 粗体(不推荐)

\* bdo - bidi override

\* big - 大字体

\* ==br== - 换行

\* cite - 引用

\* code - 计算机代码(在引用源码的时候需要)

\* dfn - 定义字段

\* ==em== - 强调

\* ==font== - 字体设定(不推荐)

\* i - 斜体

\* ==img== - 图片

\* ==input== - 输入框

\* kbd - 定义键盘文本

\* ==label== - 表格标签

\* q - 短引用

\* s - 中划线(不推荐)

\* samp - 定义范例计算机代码

\* select - 项目选择

\* small - 小字体文本

\* ==span== - 常用内联容器，定义文本内区块

\* strike - 中划线

\* strong - 粗体强调

\* sub - 下标

\* sup - 上标

\* textarea - 多行文本输入框

\* tt - 电传文本

\* u - 下划线

\* var - 定义变量

**块元素(block element)**

\* address - 地址

\* blockquote - 块引用

\* center - 举中对齐块

\* dir - 目录列表

\* ==div== - 常用块级容易，也是css layout的主要标签

\* dl - 定义列表

\* fieldset - form控制组

\* ==form== - 交互表单

\* ==h1== - 大标题

\* ==h2== - 副标题

\* ==h3== - 3级标题

\* ==h4== - 4级标题

\* ==h5== - 5级标题

\* ==h6== - 6级标题

\* hr - 水平分隔线

\* isindex - input prompt

\* menu - 菜单列表

\* noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容

\* noscript - ）可选脚本内容（对于不支持script的浏览器显示此内容）

\* ==ol== - 排序表单

\* ==p== - 段落

\* pre - 格式化文本

\* ==table== - 表格

\* ==ul== - 非排序列表

 

**可变元素可变元素为根据上下文语境决定该元素为块元素或者内联元素。**

 

\* applet - java applet

\* button - 按钮

\* del - 删除文本

\* iframe - inline frame

\* ins - 插入的文本

\* map - 图片区块(map)

\* object - object对象

\* script - 客户端脚本

 

## img的title和alt属性

**alt属性**：图片的描述，这个描述默认情况下不会显示，**有些浏览器会图片无法加载时显示**。  **搜索引擎**会根据alt中的内容来识别图片，如果不写alt属性则图片不会被搜索引擎所识别

**title**：**鼠标滑过时显示的文字提示**，用户体验上很重要。当然不必要所有的img标签都加此属性，比方说logo这样比较重要或者说用户会体验到的图片内容建议一定要加此属性。



## meta标签

元数据（metadata）是关于数据的信息。

标签提供关于 HTML 文档的**==元数据==**。**==元数据不会显示在页面上，但是对于机器是可读的==**。

典型的情况是，meta 元素被用于规定**==页面的描述==**、**==关键词==**、**==文档的作者==**、**==最后修改时间==**以及其他元数据。

标签始终位于 **==head==** 元素中。

元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。




**==meta有哪些属性==**

charset：指定网页的字符集

name：指定的数据的名称

content：指定的数据的内容（**一般content和name配合使用，一个表示元数据的名字，一个表示元素数据的内容**）

http-equiv：用于页面的重定向，content中两个参数，用分号隔开，第一个写重定向的延迟事件（秒），第二个是一个重定向地址



**==有哪些元数据（作为name属性的值）==**：

keywords：表示**网页的关键字**，便于搜索时使用，可以使用多个关键字，关键字放在content中，关键字之间用**逗号隔开**

![1616122222285](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\1616122222285.png)

description：用于指定网站的描述，**<font color='red'>描述的内容会出现在搜索引擎的结果中</font>**

author：作者

viewport：content属性为width=像素值，可以为网页指定，在网页占满手机全屏时，页面宽度为多少像素，相当于把网页放大，一个**css像素由几个物理像素来呈现**

```html
 <!--完美视口（素比设置为最佳像素比的视口大小）固定写法-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

等等





## DOCTYPE标签

\<!DOCTYPE> 声明位于文档中的最前面的位置，处于 \<html> 标签之前。

\<!DOCTYPE> 声明不是一个 HTML 标签；它是用来告知 Web 浏览器页面使用了哪种 HTML 版本。


在 HTML 4.01 中，<!DOCTYPE> 声明需引用 DTD （文档类型声明），因为 **==HTML 4.01 是基于 SGML==** （Standard Generalized Markup Language **==标准通用标记语言==**）。DTD 指定了标记语言的规则，确保了浏览器能够正确的渲染内容。

**==HTML5 不是基于 SGML==**，因此不要求引用 DTD。

**HTML 4.01 与 HTML5之间的差异**

​	HTML 4.01 规定了三种不同的 <!DOCTYPE> 声明，分别是：**Strict、Transitional 和 Frameset**。 HTML5 中仅规定了一种：

```html
<!DOCTYPE html>
```



![image-20210508105919833](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210508105919833.png)



### 标准模式与兼容模式区别：

当doctype申明**缺失**或者**格式不正确**时，文档会以兼容模式呈现。

**==标准模式==**：排版以及js运行模式都是以浏览器支持的最高标准运行；

**==兼容模式==**：页面以宽松的向后兼容方式显示，模拟老浏览器的行为防止站点无法正常工作。



在W3C标准出来之前，浏览器对页面的渲染没有统一的标准，各个浏览器对同一页面的渲染有一定的差异，而每个浏览器的不同版本对页面的渲染也有一定程度上的差异。而W3C标准出来之后，浏览器对页面的渲染就有了统一的标准。前者对于浏览器使用自己的方式渲染页面的模式，我们称之为*Quircks Mode（怪异模式、兼容模式或混杂模式）*；而对于后者浏览器按照标准解析执行代码的模式，我们称之为*Standard Mode（标准模式或严格模式）*。在标准模式中，浏览器根据规范呈现页面；在兼容模式中，页面以一种比较宽松的向后兼容的方式显示。其实，还有一种模式叫*近标准模式*，它与标准模式一致，除了在处理下面这种情况时：如果一个块级元素除了空白文本（空格，tab等字符）外再无其它内容，则它的高度按0处理；如果有子元素，则它的高度不能比子元素大，无论它的font-size多大。
 那么，浏览器解析时到底使用标准模式还是怪异模式？这就和之前提到的DOCTYPE有关了。

- 标准模式：

1. XHTML文档包含完整的DOCTYPE声明时，一般以标准模式呈现；
2. 文档包含严格DTD类型的DOCTYPE声明时，以标准模式呈现；
3. 文档包含过渡DTD类型的DOCTYPE声明且声明包含URI时，以标准模式呈现。

- 兼容模式：

1. 文档不包含DOCTYPE声明或DOCTYPE声明不正确时，以兼容模式呈现；
2. 文档包含过渡或框架DTD类型的DOCTYPE声明但声明不包含URI时，以兼容模式呈现；
3. 在IE中，如果DOCTYPE声明在XML之后，以兼容模式呈现。

**==标准模式（Standard Mode）和兼容模式（Quircks Mode）的区别==**

 最后总结一下，在标准模式和兼容模式下，页面的呈现主要有哪些区别：

- 关于盒模型：

  在标准模式下，元素width是内容宽度，即：元素实际width =元素width+ 元素padding + 元素border，（盒子的宽度还要加上元素margin的宽度）；

  在兼容模式下，元素width是元素的实际宽度，即：

  元素width= 元素内容width + 元素padding + 元素border，（盒子的宽度还要加上元素margin的宽度）。

  > 盒模型：主要针对块级元素，把每个块级元素都想象成一个盒子，每个盒子有外边距（margin）、边框（border）、内边距（padding）、内容（content）。

- 关于行内元素：

  对于行内元素的垂直对齐样式设置，基于 Gecko 的浏览器（Mozilla Firefox、HotBrowser、Mozilla Suite、Camino）标准模式对齐至基线，怪异模式对齐至底部；

  对于行内元素的高度（height）和宽度（width）的设置，标准模式下不生效，而在兼容模式下会生效。

  > 四大内核：
  >
  > - Trident，主要有IE浏览器以及多核浏览器
  > - Gecko，主要有Firefox以及Firefox的衍生浏览器
  > - WebKit，主要有Chrome与Chrome的衍生浏览器、Safari以及多核浏览器
  > - Presto，之前主要应用于Opera，Opera现已改用Google Chrome的Blink内核。

- 关于百分比的高度设置：在标准模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的。

- 关于水平居中设置：在标准模式下，使用margin:0 auto可以使元素水平居中，但在兼容模式下会失效。

- 关于!important声明：在兼容模式下，IE6/7/8下使用!important声明无效。

- 其他：兼容模式下，设置图片的padding会失效；table中的字体属性不能继承父元素的字体属性；设置white-space:pre会失效。





## script标签的 defer和 async

script 标签有2个属性 async（异步） 和 defer（推迟）；

**先说同步异步推迟的概念**

**==同步==**相当于单行道，一个加载完完之后再去加载另一个，例如HTML文档加载过程中，遇到了js标签或引入文件，需要停下来加载完js'代码再继续加载HTML代码

**==异步（async）==**相当于双行道，html代码和js代码同时加载，谁先加载完谁就先执行，不管另一个，这会出现一个问题，如果遇到js要进行dom操作但是HTML没加载完就会出错

**==推迟（defer）==**也是相当于双行道，但是在最后的出口会有要求，虽然是异步加载，但是写在文档前面的要先执行，也就是最后的执行有先后顺序，不会出现上面提到的问题，带有js脚本的如果先加载完，也要等到HTML加载完才能执行

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210508113803318.png" alt="image-20210508113803318" style="zoom:67%;" />



## W3C盒模型和怪异盒模型

盒模型，**==标准模型==**和**==怪异模型==**有什么区别？

盒模型一共有两种模式：W3C标准模式和IE怪异模式

一、标准盒子模型

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210508212725035.png" alt="image-20210508212725035" style="zoom: 67%;" />

可以看到，在标准盒模型下，width和height是内容区域即**==content的width和height==**。

**在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)**

**二、IE盒子模型**

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210508212746521.png" alt="image-20210508212746521" style="zoom: 67%;" />

 

 而IE盒模型或怪异盒模型显而易见的区别就是，width和height**==除了content区域外==**，**==还包含padding和border。==**

**一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值）**

**1、如何运用**

只要在文档首部加了**==doctype申明==**，即使用了**==标准盒模型==**，

而**==不加==**，则会**==由浏览器自己决定==**，比如，**==ie 浏览器==**中显示“ie盒子模型”，在 ff 浏览器中显示“标准 w3c 盒子模型”。

当用编辑器新建一个html页面的时候最顶上都会有一个DOCTYPE标签，==**不定义DOCTYPE，会触发怪异模式**==

**2、怪异盒模型**

CSS3的box-sizing

box-sizing语法：

box-sizing: content-box || border-box || inherit || initial

当设置为**==box-sizing:content-box==**时，将采用**==标准模式==**解析计算，也是**==默认模式==**；

当设置为**==box-sizing:border-box==**时，将采用**==怪异模式==**解析计算；









## ==水平垂直居中的方法==

https://blog.csdn.net/weixin_37580235/article/details/82317240



### 水平居中

#### 行内元素

看父元素是不是块级元素，如果是直接给父元素设置 **text-align: center**

如果不是，先将父元素display: block设置为块级元素，再给父元素设置 **text-align: center;**

#### 块级元素

##### 子元素宽度不定

###### 将其转换为行内元素居中

默认子元素的宽度和父元素一样，这时需要设置子元素为**display: inline-block**或 display: inline即**==将其转换成行内块级/行内元素==**，给父元素设置 **text-align: center** 

###### 使用定位属性和transform

首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的**left:50%**，即让子元素的左上角水平居中；

利用css3新增属性在子元素上**transform: translateX(-50%);**

##### 子元素宽确定

###### 利用margin的auto

需要谁居中，给其设置 **margin: 0 auto** （作用：使盒子自己居中）

###### 使用定位属性

首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的**left:50%**，即让子元素的左上角水平居中；

设置绝对子元素的 **margin-left: -元素宽度的一半px** 

###### 使用flex布局

使用flexbox布局，只需要给待处理的块状元素的父元素添加属性 **display: flex; justify-content: center;**

### 垂直居中

#### 单行的行内元素

行高（line-height）和父元素高度（height）设置成一样的,实现垂直居中

#### ==多行的行内元素==

使用给父元素设置**display:table-cell**和**vertical-align: middle;**属即可；

> 我们将容器设为display:table，然后他成为一个**块级表格元素**
>
> 子元素设置display:table-cell使子元素成为**表格单元格**，然后就像在表格里一样，给子元素加个vertical-align: middle就行了，多行文字垂直居中啦。是不是很直接很简洁~

#### 块级元素

##### 使用定位

首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的**top: 50%**，即让子元素的左上角垂直居中；

**定高度：**设置绝对子元素的 **margin-top: -元素高度的一半px** 或者设置**transform: translateY(-50%);**

**不定高度：**利用css3新增属性**transform: translateY(-50%);**

##### **使用flex布局实现**

使用flexbox布局，只需要给待处理的块状元素的父元素添加属性 **display: flex; align-items: center;**



### 水平垂直居中

#### 行内元素

父元素text-align:center

父元素的height等于子元素的line-height

#### 块级元素

##### 已知高宽

###### 方案一：利用margin的auto

设置父元素为相对定位，给子元素设置绝对定位，**top: 0; right: 0; bottom: 0; left: 0; margin: auto;**

###### 方案二：使用定位

设置父元素为相对定位，给子元素设置绝对定位，**left: 50%; top: 50%; margin-left: -元素宽度的一半px; margin-top: -元素高度的一半px**

##### 未知高宽

###### 方案一：使用定位+transform

设置父元素为相对定位，给子元素设置绝对定位，**left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%);**

###### **方案二：**使用flex布局实现

设置父元素为flex定位，**justify-content: center; align-items: center;**











## 清除浮动的方法

详见解决高度塌陷的问题



## position属性

详见笔记



## css隐藏元素的方式

使用css让元素不可见的方法有很多种，裁剪、定位到屏幕外边、透明度变换等都是可以的。但是最常用两种方式就是设置元素样式为**display: none**或者**visibility: hidden**。很多公司的面试官也常常会问面试者这两者之间的区别。

### display与元素的隐藏

如果给一个元素设置了display: none，那么该元素以及它的所有后代元素都会隐藏，它是前端开发人员使用频率最高的一种隐藏方式。隐藏后的元素无法点击，无法使用屏幕阅读器等辅助设备访问，占据的空间消失。  

```html
<body>
    <div>
        <strong>给元素设置display:none样式</strong>
        <p>A元素</p>
        <p style='display:none;'>B元素</p>
        <p>C元素</p>
    </div>
</body>
```

效果图：

![image-20210509114746549](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509114746549.png)

### visibility与元素的隐藏

给元素设置visibility: hidden也可以隐藏这个元素，但是隐藏元素仍需占用与未隐藏时一样的空间，也就是说虽然元素不可见了，但是仍然会影响页面布局。

```html

<body>
    <div>
        <strong>给元素设置visibility:hidden样式</strong>
        <p>A元素</p>
        <p style='visibility:hidden;'>B元素</p>
        <p>C元素</p>
    </div>
</body>
```

效果图：

![image-20210509114839109](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509114839109.png)

### display: none与visibility: hidden的区别

很多前端的同学认为visibility: hidden和display: none的区别仅仅在于display: none隐藏后的元素不占据任何空间，而visibility: hidden隐藏后的元素空间依旧保留 ，实际上没那么简单，visibility是一个非常有故事性的属性

1、visibility具有继承性，**给父元素设置visibility:hidden;子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。**这个和display: none有着质的区别

2、visibility: hidden不会影响计数器的计数，如图所示，visibility: hidden虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样

```html

<body>
    <div>
        <strong>给元素设置visibility:hidden样式</strong>
        <ol>
            <li>元素1</li>
            <li style="visibility:hidden;">元素2</li>
            <li>元素3</li>
            <li>元素4</li>
        </ol>
    </div>
    <div>
        <strong>给元素设置display:none样式</strong>
        <ol>
            <li>元素1</li>
            <li style="display:none;">元素2</li>
            <li>元素3</li>
            <li>元素4</li>
        </ol>
    </div>
</body
```

![image-20210509114946500](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509114946500.png)

3、**CSS3的transition支持visibility属性，但是并不支持display**，由于transition可以延迟执行，因此可以配合visibility使用纯css实现hover延时显示效果。提高用户体验。



## Flex布局

查看笔记



## 双栏布局和三栏布局

### 两栏布局

**<font color='red'>左列定宽浮动，右列使用margin来解决遮挡问题</font>**

![image-20210509144044872](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509144044872.png)

**<font color='red'>左列定宽浮动，右列开启BFC，BFC元素不会被浮动元素遮盖</font>**

![image-20210509145802943](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509145802943.png)

**<font color='red'>！！！！父元素开启相对定位，左边子元素开启绝对定位，相当于开启BFC后脱离文档流，不再独占一行</font>**

![image-20210509150014478](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509150014478.png)

**<font color='red'>父元素使用flex弹性盒</font>**

![image-20210509150122490](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509150122490.png)

**<font color='red'>使用浮动，左边开启左浮动，右边开启右浮动</font>**

![image-20210509153340684](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509153340684.png)

**<font color='red'>table布局</font>**

将容器设为display:table然他成为一个块级表格元素，子元素display:table-cell使子元素成为表格单元格，然后就像在表格里一样

![image-20210509153501068](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509153501068.png)



### ==三栏布局==

**<font color='red'>两边浮动+中间margin</font>**

![image-20210509160058087](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509160058087.png)



**<font color='red'>两边浮动+中间开启BFC，BFC元素不会被浮动元素覆盖</font>**

![image-20210509160224668](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509160224668.png)

**<font color='red'>flex布局，两边定宽，中间flex:1，占满剩余空间</font>**

![image-20210509160336199](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509160336199.png)

**<font color='red'>使用table布局，父元素displ:table，子元素display:table-cell</font>**

![image-20210509160613689](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509160613689.png)

**<font color='red'>使用定位，父元素相对定位，左右哦元素绝对定位，中间元素margin空出左右位置</font>**

​	![image-20210509160817972](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509160817972.png)

**<font color='red'>圣杯布局</font>**

https://www.bilibili.com/video/BV17J411x7Mo?from=search&seid=8752309673106365261https://www.bilibili.com/video/BV17J411x7Mo?from=search&seid=8752309673106365261

dom标签先中间后左右

额外一个div标签包裹这三个元素

中间区域宽度100%，左右100px

设置全部左浮动，并解决高度塌陷的问题

左区域margin-left:-100%（这一步下一步比较难理解）

右区域margin-left:-100px

外部div加上100px的padding

左右区域开启相对定位，分别左右移动100px

**==代码==**

![image-20210509171004447](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509171004447.png)

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509165418456.png" alt="image-20210509165418456" style="zoom: 67%;" />

**<font color='red'>双飞翼布局</font>**

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509170043200.png" alt="image-20210509170043200" style="zoom:67%;" />

dom标签先中间后左右

额外一个div标签包裹中间区域

中间区域宽度100%，左右100px

中间区域的外部div、左右区域三个部分开启向左浮动

底部foot消除浮动

左区域margin-left:-100%（这一步下一步比较难理解）

右区域margin-left:-100px

中间区域内部div加上左右100px的margin



**==区别总结：==**

双飞翼布局其实和圣杯布局的精髓是一样的，都是通过设置负margin来实现元素的排布，不同的就是html结构，**==双飞翼是在中间元素外边又设置了一层div，设置内部div的左右margin==**，**==而非圣杯布局的最外层父元素加上padding、两边在进行左右移动==**，来排除两边元素的覆盖。





## css选择器优先级



## css动画

​	animation属性

​	transition属性





## css响应式布局







## css实现三角形

**==设置一个div，宽高设置为0，设置四个边的边框一定宽度，并且只留一个边的边框，其他全部都变透明==**

![image-20210509173222083](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210509173222083.png)

## css Sprites

见笔记



## px rem em rpx

**==像素==**

px

屏幕（显示器）实际上是由一个个的小点点构成的

不同屏幕的像素大小是不同的，像素越小的屏幕显示的效果越清晰

所以同样的200px，在不同的设备下显示效果不一样



**==百分比==**

可以将属性值设置为**==相对于其父元素属性的百分比==**

设置百分比可以使子元素**==跟随父元素的改变而改变==**



**==em==**

em是相**对于==元素的字体大小==来计算的**，**==em是相对于它的父级的font-size的倍数==**，**==几em就是几倍的font-size的字体大小==**

**==1em =1font-size==**

**em会根据字体大小的改变而改变**

**<font color='orange'>浏览器默认字体大小为16px</font>**

如下图，这是font-size字体大小设置的就为30px，换算后，长宽就为300px了

![1616240721966](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\1616240721966.png)

**==rem==**

rem用法和em差不多，**==是相对于根元素（HTML）的字体大小来计算的==**

根元素字体大小默认的是**==16px==**

### px 与 rem 的选择？

对于只需要适配少部分手机设备，且分辨率对页面影响不大的，**==使用px即可 。==**

对于需要适配各种移动设备，**==使用rem==**，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备。

### rpx

**==rpx （ responsive pixel）响应单位==**

rpx是微信小程序独有的、解决屏幕自适应的尺寸单位

可以根据屏幕宽度进行自适应，**<font color='red'>不论大小屏幕，规定屏幕宽为750rpx</font>**

通过 rpx 设置元素和字体的大小，小程序在不同尺寸的屏幕下，可以实现自动适配



==rpx 和 px之间的换算==

在普通网页开发中，最常用的像素单位是px

在小程序开发中，推荐使用rpx这种响应式的像素单位进行开发

以 iPhone6 为例，iPhone6 的屏幕宽度为 375px，共有 750个物理像素，则 750rpx = 375px = 750 物理像素

得出公式：1 rpx = 0.5 px = 1 物理像素

举个例子：在iPhone6上，如果要绘制一个宽为100px，高为30px的盒子，换算成rpx单位，宽高分别为200rpx 和 60rpx



**==rpx 和 iPhone 设计稿的关系==**

官方建议：开发微信小程序时，设计师可以以iPhone6 作为视觉稿的标准，如果要根据iPhone6的设计稿，绘制小程序的页面，可以

直接把单位 px 替换成 rpx 。例如：假设iPhone6设计稿上，要绘制一个宽高为 200px 的盒子，换算为 rpx为200rpx



**==以iPhone6为设计稿标准，单位 px 直接替换成 rpx的原因==**

设计师在出设计稿的时候，出的都是二倍图，也就是说如果在这个设计稿上有一个宽高为200px的盒子，那么它最终画到页面上实际

上是一个宽高为100px的盒子，那么再换算成rpx需要乘以2，就又变成了200rpx，跟设计稿上的数字是一样的，所以我们可以保持数

字不变，直接将单位 px 替换成 rpx

## 伪元素/伪类

见笔记













## html5和css3

### 新增标签

#### 新增语义化标签

全是块级元素

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210521181107937.png" alt="image-20210521181107937" style="zoom:80%;" />

#### HTML4 到HTML5语义化标签迁移

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210521181517117.png" alt="image-20210521181517117" style="zoom:80%;" />

#### 新增媒体标签

html5提供了音频和视频文件的标准，既使用<audio>元素。

音频：\<audio src=" ">\</audio>

```html
<audio controls>    //controls属性提供添加播放、暂停和音量控件。
  <source src="horse.ogg" type="audio/ogg">
  <source src="horse.mp3" type="audio/mpeg">
您的浏览器不支持 audio 元素。        //浏览器不支持时显示文字
</audio>
```

视频：\<video src=" ">\</video>

```html
<video width="320" height="240" controls>
  <source src="movie.mp4" type="video/mp4">
  <source src="movie.ogg" type="video/ogg">
您的浏览器不支持Video标签。
</video>
```



#### 新增图形标签

##### canvas标签

https://www.runoob.com/w3cnote/html5-canvas-intro.html



##### svg标签

svg标签里面时矢量图，平时我们也可以用svg格式的图片，就用img引用就行了

svg标签里面是使用XML格式定义的图片，里面有各种绘制图形的代码

但是单独拿出来一个svg标签好处在于，可以在页面中修改这个svg标签，可以通过修改一些参数值来改变图形



两者区别

SVG与Canvas区别

*SVG适用于描述XML中的2D图形的语言

*Canvas随时随地绘制2D图形（使用javaScript）

*SVG是基于XML的，意味这可以操作DOM，渲染速度较慢

*在SVG中每个形状都被当做是一个对象，如果SVG发生改变，页面就会发生重绘

*Canvas是一像素一像素地渲染，如果改变某一个位置，整个画布会重绘。

| Canvas                           | SVG                        |
| -------------------------------- | -------------------------- |
| 依赖分辨率                       | 不依赖分辨率               |
| 不支持事件处理器                 | 支持事件处理器             |
| 能够以.png或.jpg格式保存结果图像 | 复杂度会减慢搞渲染速度     |
| 文字呈现功能比较简单             | 适合大型渲染区域的应用程序 |
| 最合适图像密集的游戏             | 不适合游戏应用             |

### 新增的input类型和属性

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210521181352327.png" alt="image-20210521181352327" style="zoom:80%;" />



### 新增样式

阴影

选择器

动画

过渡

### 本地存储Storage和sessionStorage



### **地理定位**

使用getCurrentPosition()方法来获取用户的位置。以实现“LBS服务”

```html
<script>
var x=document.getElementById("demo");
function getLocation()
  {
  if (navigator.geolocation)
    {
    navigator.geolocation.getCurrentPosition(showPosition);
    }
  else{x.innerHTML="Geolocation is not supported by this browser.";}
  }
function showPosition(position)
  {
  x.innerHTML="Latitude: " + position.coords.latitude +
  "<br />Longitude: " + position.coords.longitude;
  }
</script>
```

### **拖放API**



### Web Worker



### HTML5兼容问题















## 响应式布局

见笔记









## 垂直居中一个浮动元素怎么做

宽高确定

```css
.child{
	width: 100px;
	height: 100px;
	background-color:darkcyan;
	float: left;
	position: absolute;//父元素需要相对定位
	top:50%;
	left:50%;
	transform: translate(-50%,-50%);
}
/*或者*/
.child{
	width: 100px;
	height: 100px;
	background-color:darkcyan;
	float: left;
	position: absolute;//父元素需要相对定位
	top:50%;
	left:50%;
	margin-top: -50px;
	margin-left: -50px;
}
```

宽高不定

```css
.child {
	width: 100px;
	height: 100px;
	background-color: darkcyan;
	float: left;
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	margin: auto
}
```

垂直居中一个`img`

```css
//<img>的容器
.img-container{
	display: table-cell;
	vertical-align: middle;
	text-align: center;
}
/*或者*/
.img-container{
	display: flex;
	justify-content: center;
	align-items: center;
}
```



## rgba和opacity的透明效果有什么不同

1.opacity 是属性，rgba()是函数，计算之后是个属性值；

2.opacity 作用于**==元素和元素的内容==**，内容会**==继承==**元素的透明度，取值0-1；

3.rgba() 一般作为**==背景色==** background-color 或者**==颜色 color 的属性值==**，透明度由其中的 alpha 值生效，取值0-1；











### 

# ==-------------------------==



# JS

## script标签和body顺序

建议将script标签放在body标签后面，因为是script中执行dom操作时，如果html代码没有加载完会出错或者无效

但是这样也有问题，在script中代码没有加载完，页面中会有短暂的空白，因为js代码中的数据还没渲染完

**个人建议：利用script标签中的defer属性，开启推迟效果，将script放在body代码前面，js代码和HTML代码异步执行，但是defer属性规定，无论js还是HTML代码哪个先加载完，只能HTML标签等加载完之后再执行**

## 数据类型

基本数据类型：String，boolean，Number，Symbol（ES6新增），Undefined，Null

引用数据类型：Object

基本数据类型中有两个为特殊数据类型： null, undefined 

js的常见内置对象：Date，Array，Math，Number，Boolean，String，Array，RegExp，Function...

```javascript
Object.prototype.toString.call(function(){}); //"[object Function]"//这个方法就建立在js任何类型皆可视为对象
```

前5种属于**基本数据类型**，Object属于**引用数据类型**



### 	Symbol的作用

Symbol时es6新增的语法，详情见笔记







## 判断变量的类型



Object.toString().call()及原理[[class]]

​	typeof null //"object"

​	判断数组的方法

​	判断空对象的方法



**==typeof==**：返回数据类型的字符串表达



**==instanceof==**：使用instanceof可一检查一个对象是否是一个**类的实例**，返回值是一个布尔值

**==语法console.log(a instanceof b)==**

其中b应当是一个构造函数

注意，这里构造函数可以是自己定义的 ，也可以是**Object、Array、Function**，因为创建对象、数组、函数的时候，有一种方法就是使用构造函数new一个

**所以b是Object、Array、Function时，就是用来判断a是不是数组、对象、函数**

**其中数组、函数都属于对象**



**==\=\=\===**：只有undefined和null可以用三个等号来判断



```javascript
//判断undefined类型
var a;
console.log(typeof a==='undefined',a===undefined);
//判断数值类型
a=3;
console.log(typeof a ==='number');
//判断字符串类型
a='atguigu';
console.log(typeof a ==='string');
//判断布尔值
a= true;
console.log(typeof a ==='boolean');
//判断null类型
a = null;
console.log(a ===null)
//判断对象类型
var b1 = {
    b2: [1,'abc',console.log],
    b3: function(){
        console.log('b3')
    }
}
console.log(b1 instanceof Object)//true
console.log(b1.b2 instanceof Array,b1.b2 instanceof Object)//true true
console.log(b1.b3 instanceof Function,b1.b3 instanceof Object)//true true
console.log(typeof b1.b3)//function
console.log(typeof b1.b2)//object
console.log(typeof b1)//object
```

**<font color='red'>总结：</font>**

Number、String、Boolean、Null、Undefined、Function、Object类型可以用typeof来判断或者查看

但是Array、Data等Object类型的判断不了

使用instanceof来判断各种**==引用类型==**或者**==自己创建的构造函数==**，不能判断基本类型



### instanceof原理

其真正含义是判断一个构造函数的prototype属性所指向的对象是否在另一个被检测对象的原型链上

```javascript
function Animal() {}
var a = new Animal();
function Cat() {}

var c1 = new Cat();
Cat.prototype = a;//改变Cat的原型
var c2 = new Cat();

console.log(c1 instanceof Cat); // false
console.log(c2 instanceof Cat); // true
console.log(c1 instanceof Animal);  // false
console.log(c2 instanceof Animal);  // true
```





### 相等和全等

相等是“\==”，而全等是“===”，相等和全等的区别，总结就是：

相等 \==： 先转换类型再比较

全等 \=\==：直接比较，不转换类型，只要是类型不同就不相等，类型相同的看值是否相等

**==Object.is(value1,value2)==**：ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（\=\==）的行为基本一致。

**==Object.is与“\=\==”不同之处只有两个==**：一是+0不等于-0，二是NaN等于自身。

```javascript
55 == "55"        // true
55 === "55"       // false
```

分析代码，对于相等来说”55”会被转换成number类型的55，所有比较后相等，但是对于全等来说，”55”不会被转换，由于类型不同（一个number一个String）所有比较之后为false,所以对于全等来说，必须保证数据类型也相同

#### 相等转换规则：

- 对于==boolean==值，false转换为0，true转换为1

```javascript
true == 1 // true
true == 2 // false
```

- 如果一个操作数是==字符串==，另一个是数值，比较之前将**字符转换为数值**

```javascript
"5" == 5  // true
```

- ==null 与 undefined比较是相等的==，而且对比之前不能将null与undefined转换成其他值

```javascript
null == undefined // true
null == 0         // false
undefined == 0    // false
```

- 如果两个操作数是==对象==，那么比较他们是不是指向同一个对象。

```javascript
var a = {}
var b =a
a == b // true
c = {}
a == c // false
```

- 有一个操作符为NaN就返回false

```javascript
NaN == NaN  // false
5 = NaN     // false
NaN === NaN //false
```

- 如果其中一方是否为 object 且另一方为 string、number 或者 symbol , 将 object 转为原始类型再进行判断

```javascript
let person1 = {
    age: 25
}
let person2 = person1;
person2.gae = 20;
console.log(person1 === person2); //true,注意复杂数据类型，比较的是引用地址
```

- new Number（）是一个内置的函数构造函数。 虽然它看起来像一个数字，但它并不是一个真正的数字：它有一堆额外的功能，是一个对象。当我们使用\==运算符时，它只检查它是否具有相同的值，所以a和b是相等的；然而，当我们使用\===操作符时，类型和值都需要相等，b和a与c的类型不一样，所以不等。

> `==`会引发隐式类型转换，右侧的对象类型会自动拆箱为`Number`类型。

```javascript
let a = 3;
let b = new Number(3);
let c = 3;
 
console.log(a == b);   //true
console.log(a === b);  //false
console.log(b === c);  //false
```



**==思考题==**

思考：我们来分析一下: [] == ![] 是true还是false？

首先，我们需要知道 ! 优先级是高于 == (更多运算符优先级可查看: 运算符优先级)

![] 引用类型转换成布尔值都是true,因此![]的是false

根据上面的比较方法，其中一方是 boolean，将 boolean 转为 number 再进行判断，false转换成 number，对应的值是 0.

根据上面比较方法，有一方是 number，那么将object也转换成Number,空数组转换成数字，对应的值是0.(空数组转换成数字，对应的值是0，如果数组中只有一个数字，那么转成number就是这个数字，其它情况，均为NaN)

0 == 0; 为true






### 包装类型

为了便于操作“基本类型值”，JS 提供了 三个 特殊的引用类型：**Boolean、Number、String**。这些类型和其他引用类型相似，但同时 也具备 与各自基本类型相应的特殊行为。 **<font color='red'>实际上：每当读取一个基本类型值的时候， “后台就会创建一个 对应的基本包装类型的对象”，从能能够调用一些方法来操作这些数据。这也就是我们为什么能在基本数据类型上面使用一些方法</font>** 

1、String对象

String对象是基本类型，但是也是特殊的引用类型（基本包装类型：内部创建对象，可以调用它自己内部的特殊行为）

**1、String是基本包装类型：**

```javascript
1 var box ='Mr.Xiao';     //字面量创建方式
2 
3 alert(box.substring(2)); //box 是基本类型，但是也是特殊的引用类型，在后台 会创建一个 基本包装类型的对象；；所以可以调用 系统内置的函数
```

**2、String对象不是引用类型（因为无法动态添加属性和方法）**

```javascript
1 //注意  这种简单类型不是引用类型（因为他们不能 添加属性和方法）
2 box.name='xiao';
3 box.age=function(){
4        return 10;
5     }
6 
7 alert(box.name);  //undefined
8 alert(box.age());  //报错
```

**3、使用New修饰符创建的String对象就是Object引用类型的对象**

new修饰符创建的对象是引用类型，可以动态添加属性和方法。

```javascript
1 var box =new String('Mr.Xiao');
2 box.name="xiao";
3 box.age=function(){
4       return 10;
5     }
6 alert(box.name);   //xiao
7 alert(box.age());   //10
8 alert(box.substring(2));  // .Xiao  也是可以执行的
```

**4、String内部的方法和属性**

![img](https://images0.cnblogs.com/i/579331/201403/271003348272738.png)

## 原型和原型链

### 描述构造函数、实例和原型之间的关系

见笔记



## 闭包

### 优缺点

见笔记



## call/apply/bind

见笔记



## DOM事件流和事件委托

### 事件委托及好处

事件的委派

指将事件统一定给元素的**共同的祖先元素**，这样当后代元素上的事件触发时，会一直冒泡到祖先元素

**从而通过祖先元素的响应函数来处理事件**。

事件委派是利用了冒泡，**==通过委派可以减少事件绑定的次数，提高程序的性能==**

### 事件捕获、冒泡

见笔记





## cookie和storage

cookie的构成

localStorage和sessionStorage

cookie的HTTPOnly





### cookie 组成结构

1.用抓包工具 fidller 只能看到 cookie 的 name 和 value 两个参数，实际上 cookie 还有其 它参数

2.以下是一个完整的 cookie 组成结构 

cookie ={u'domain': u'.cnblogs.com', u'name': u'.CNBlogsCookie', u'value': u'xxxx', u'expiry': 1491887887, u'path': u'/', u'httpOnly': True, u'secure': False} 

**==name==**：cookie 的名称 

**==value==**：cookie 对应的值，动态生成的 

**==domain==**：服务器域名 

**==expiry==**：Cookie 有效终止日期 

**==path==**：Path 属性定义了 Web 服务器上哪些路径下的页面可获取服务器设置的 Cookie 

**==httpOnly==**：防脚本攻击 

**==secure==**：在 Cookie 中标记该变量，表明只有当浏览器和 Web Server 之间的通信协议为加密 认证协议时， 浏览器才向服务器提交相应的 Cookie。当前这种协议只有一种，即为 HTTPS。

### 什么是HttpOnly?

**==如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容，这样就增加了cookie的安全性==**。即便是这样，也不要将重要信息存入cookie。

XSS全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。




### localStorage和sessionStorage

localStorage介绍：https://www.cnblogs.com/wugongzi/p/11549707.html

html5中的Web Storage包括了两种存储方式：localStorage和sessionStorage一样都是用来存储客户端临时信息的对象。

sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问
并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅、是会话级别的存储。只允许同一窗口访问。



而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。同源可以读取并修改localStorage数据。





## 数组对象的常见方法

Array：slice splice concat filter map reduce



**==改变原数组的方法==**：pop（出栈）、push（入栈）、reverse（倒序）、shift（删第一个元素），unshift（开头添加一个多个元素）、sort（排序）、splice（删除或插入元素）

（这七个方法也会在vue中进行改写，实现数组的响应式）

**==不改变原数组的方法==**：concat（连接多个数组）、join（转字符串）、slice（截取一段数组）

### ==数组去重==

错误记载，以下方式不行

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513163851601.png" alt="image-20210513163851601" style="zoom:80%;" />

```javascript
//数组去重
		
//利用splice，循环两次
function unique8(arr) {
    var i,j,len = arr.length;
    for (i = 0; i < len; i++) {
        for (j = i + 1; j < len; j++) {
            if (arr[i] == arr[j]) {
                arr.splice(j, 1);
                len--;
                j--;
            }
        }
    }
    return arr;
}
console.log(unique8([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));

//利用filter和includes
function unique6(arr) {
    var newArr = []
    newArr = arr.filter(function (item) {
        return newArr.includes(item) ? '' : newArr.push(item)
    })
    return newArr
}
console.log(unique6([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));
// 结果是[1, 2, 3, 5, 6, 7, 4]

//利用forEach
function unique7(arr) {
    let newArr = [];
    arr.forEach(item => {
        return newArr.includes(item) ? '' : newArr.push(item);
    });
    return newArr;
}
console.log(unique7([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));
// 结果是[1, 2, 3, 4, 5, 6, 7]


// 利用Set
function unique10(arr) {
    let newArr = [...new Set(arr)];
    return newArr
}
console.log(unique10([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4]));
// 结果是[1, 2, 3, 5, 6, 7, 4]
```

上面这四种方法其实总结起来也就**<font color='red'>三种</font>**

①for循环两边，挨个对比是否有重复的，有的话就去掉

②利用某些方法：forEach、filter，这些方法本身自带循环属性，然后只用for循环一遍，

③利用es6中的Set，Set中不能有重复的元素，然后用扩展运算符将Set转化为数组

### Object.assign()

**<font color='red'>如果参数是非对象类型：</font>**

​	**在首参数位置的话**：这些参数都会转成对象，**==如果无法转成对象，就会跳过==**。这意味着，如果`undefined`和`null`不在首参数，就==不会报错==。

​	**不在首参数位置**：其他类型的值（即**==数值、字符串和布尔值、数组==**）不在首参数，也不会报错。

​	但是

​	**<font color='red'>字符串</font>**会以数组形式（不是数组，只是索引:元素的形式），拷贝入目标对象，

​	**<font color='red'>数组</font>**可以直接进行数组上面的操作。

​	**<font color='red'>取值函数</font>**不会复制这个函数，而是拿到结果，然后**==将{函数值:返回值}这个对象复制过去==**

​	**==其他值都不会产生效果。==**

​	

### Object.key()



### Object.defineProperty()





## new对象时内部都做了什么

1. 创建一个空对象
2. 让this值指向这个空对象，并执行构造函数的内容
3. 设置原型链，使\__proto__指向构造函数的prototype
4. 返回这个新对象





## 防抖和节流

**==防抖==**是针对同一时间在短时间内连续触发某一事件，需要设置一个时间间隔，**每次触发事件就重新计时**，防止误操作和不必要的资源消耗

**==节流==**是也针对在一定事件内连续触发某一事件，需要设置一个时间间隔，在一定时间间隔内不能再次进行事件的触发，**每次事件触发时开始计时，直到过了一段时间间隔后才能再次触发**



### 防抖例子

![image-20210511150814661](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210511150814661.png)

**==本例难点：==**

①在debounce函数中需要一个return，将执行的函数return回来，因为dbounce是作为回调函数的，**==一般的回调函数都是直接写在事件绑定的那里，作为匿名函数，不会立即执行==**，但是这里debounce还要传参，得加括号，加了括号就立即执行了，**==为了防止立即执行，函数的内容通过匿名函数return回去==**

②清除计时器的话需要将计时器赋值给一个变量，这样才可以清除上一个计时器

③**==需要将定时器的名字变量放在匿名函数外面==**，利用闭包调用，如果也放在return返回的匿名函数里面的话，每次相当于新建了一个timer变量，**==放在外面的话就可以每次都使用同一个了==**

④**==定义这个回调函数的时候this已经变成了windows==**，**==如果不使用防抖直接事件绑定payMoney函数this指向的就是这个按钮元素，这是事件绑定的特点==**，为了让this指向按钮元素，**==需要在回调函数中记录this的值，并利用apply来修改payMoney函数的this==**，同时还可以利用apply来传递参数，但是这里只是简单的演示，并没有实际使用参数



### 节流例子

**==使用计时器==**

![image-20210511170230983](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210511170230983.png)

**==关键点在于每次使用完计时器后，在计时器的回调函数中就直接将这个计时器删掉==**：**==timer=null==**

这样每次在一开始需要判断if(timer)，若为false，则代表计时器还没有被销毁，计时仍在继续，不能进行操作，若为true，则代表计时结束，计时器已经置为null，可以开启新的计时器，并进行操作



**==使用Date()函数==**

![image-20210511170736654](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210511170736654.png)

跟上一个差不多，只不过使用时间戳来判断时间间隔

**==例子中有一个理解难点==**：在第一次调用回调函数的时候，用当下的时间戳-0，这样做其实是可以的，因为第一次点击并不会考虑上一次点击的问题，而且当下的时间戳-0必定会大于设定的时间间隔，而且每次执行完后，pre=now，之前的0就变成的上一次时间戳

之后再进行点击的时候，就正常判断了







## requestAnimationFrame

在Web应用中，实现动画效果的方法比较多，JavaScript 中可以通过定时器 **==setTimeout 、setInterval==**来实现，css3 可以使用 **==transition 和 animation==** 来实现，html5 中的 **==canvas==** 也可以实现。

除此之外，html5 还提供一个专门用于请求动画的 API，即 **==requestAnimationFrame（rAF）==**，顾名思义就是 “**==请求动画帧==**”**。** 

### 屏幕绘制频率

即图像在屏幕上更新的速度，也即**==屏幕上的图像每秒钟出现的次数==**，它的单位是**==赫兹(Hz)==**。 对于一般笔记本电脑，这个频率大概是60Hz

因此，**当你对着电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率正在不断的更新屏幕上的图像**。这中间只间隔了16.7ms(1000/60≈16.7)

### CSS 动画原理

60Hz 的屏幕每 16.7ms 绘制一次，如果在屏幕每次绘制前，将元素的位置向左移动一个像素，即1px，这样一来，屏幕每次绘制出来的图像位置都比前一个要差1px，你就会看到图像在移动；而由于人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，这样你所看到的效果就是，图像在流畅的移动。

### **setTimeout、setInterval的问题**

理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但我们会发现，利用 seTimeout 实现的动画在某些低端机上会出现**==卡顿==**、**==抖动==**的现象。 这种现象的产生有**==两个原因==**：

- setTimeout 的执行时间并不是确定的。在JavaScript中， setTimeout 任务被放进了**==异步队列==**中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以 **==setTimeout 的实际执行时机一般要比其设定的时间晚一些。==**
- 刷新频率受 **屏幕分辨率** 和 **屏幕尺寸** 的影响，不同设备的屏幕绘制频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，**==这个时间不一定和屏幕的刷新时间相同==**。

以上两种情况都会导致 **==setTimeout 的执行步调和屏幕的刷新步调不一致==**，从而引起**==丢帧==**现象。 

> 那为什么步调不一致就会引起丢帧呢？ 
>
> 首先要明白，setTimeout 的执行只是在内存中对元素属性进行改变，这个变化必须要等到屏幕下次绘制时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素。假设屏幕每隔16.7ms刷新一次，而setTimeout 每隔10ms设置图像向左移动1px， 就会出现如下绘制过程（表格）：
>
> - 第  0  ms：屏幕未绘制，  等待中，setTimeout 也未执行，等待中；
> - 第  10 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置元素属性 left=1px；
> - 第 16.7 ms：屏幕开始绘制，屏幕上的元素向左移动了 1px， setTimeout 未执行，继续等待中；
> - 第  20 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=2px;
> - 第  30 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=3px;
> - 第33.4 ms：屏幕开始绘制，屏幕上的元素向左移动了 3px， setTimeout 未执行，继续等待中；
> - ...
>
> 从上面的绘制过程中可以看出，屏幕没有更新 left=2px 的那一帧画面，元素直接从left=1px 的位置跳到了 left=3px 的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。

### rAF

与 setTimeout 相比，rAF 最大的优势是 **==由系统来决定回调函数的执行时机。==**

具体一点讲就是，**系统每次绘制之前会主动调用 rAF 中的回调函数**，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。

换句话说就是，**==rAF 的执行步伐跟着系统的绘制频率走==**。**它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次**，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。



**==除此之外，rAF 还有以下两个优势：==**

**==CPU节能==**：使用 setTimeout 实现的动画，**==当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务==**，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，而且还浪费 CPU 资源。**==而 rAF 则完全不同，当页面处理未激活的状态下，该页面的屏幕绘制任务也会被系统暂停==**，因此跟着系统步伐走的 rAF 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。

**==函数节流==**：在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，**==使用 rAF 可保证每个绘制间隔内，函数只被执行一次==**，这样既能保证流畅性，也能更好的节省函数执行的开销。一个绘制间隔内函数执行多次时没有意义的，因为显示器每16.7ms 绘制一次，多次绘制并不会在屏幕上体现出来。





## this的指向

见笔记



## 上下文

https://www.cnblogs.com/echolun/p/11438363.html





补充：

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210514160841167.png" alt="image-20210514160841167" style="zoom:67%;" />





面试题例子：

```javascript
for(var i=0;i<5;i++){
    setTimeout(function(){
        console.log(i++);
    },4000)
}//根据js运行机制，先执行初始化代码和设定setTimeout函数，然后再执行回调函数，所以回调函数这时候会几乎很短时间先后开启，输出效果就是循环等待4s，一下子输出5个数，因为先执行了循环，所以5个数是5、6、7、8、9
console.log(i)


//如果想循环输出的是0 1 2 3 4，主要思路是修改回调函数循环执行的上下文，不要再使用for循环的i了，解决方法是在setTimeout外面套一个立即执行函数，函数的上下文里面每次的形参都是固定的，跟外面的i就没有关系了
for(var i=0;i<5;i++){
    (function(i){
        setTimeout(function(){
            console.log(i++);
        },4000)
    })(i)
}
console.log(i)
```



## 作用域链

见笔记

## let/var/const

见笔记

## 异步编程：Promise和async await

### Promise

Promise.race和Promise.all





### async await

**<font color='red'>async 函数返回的是一个 Promise 对象。await 必须用在 async 函数中</font>**

如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。

```javascript
async function testAsync() {
    return "hello async";
}

const result = testAsync();
console.log(result);//Promise { 'hello async' }
```

async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：`then()` 链来处理这个 Promise 对象，就像这样

```javascript
testAsync().then(v => {
    console.log(v);    // 输出 hello async
});
```



因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，**==它等的实际是一个返回值==**。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。

```javascript
function getSomething() {
    return "something";
}

async function testAsync() {
    return Promise.resolve("hello async");
}

async function test() {
    const v1 = await getSomething();
    const v2 = await testAsync();
    console.log(v1, v2);
}

test();
```



await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，`await` 是个运算符，用于组成表达式，**==await 表达式的运算结果取决于它等的东西==**。

​	**如果它等到的不是一个 Promise 对象**，那 await 表达式的运算结果就是它等到的东西。

​	**如果它等到的是一个 Promise 对象**，await 就忙起来了，它会**==阻塞==**后面的代码，等着 Promise 对象 resolve，**==然后得到 resolve 的值，作为 await 表达式的运算结果==**。

> 看到上面的阻塞一词，心慌了吧……放心，这就是 **==await 必须用在 async 函数中的原因==**。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。



#### async/await 的优势在于处理 then 链

单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又**==用 async/await 来进一步优化它==**）。



例子1：

```javascript
/**
 * 传入参数 n，表示这个函数执行的时间（毫秒）
 * 执行的结果是 n + 200，这个值将用于下一步骤
 */
function takeLongTime(n) {
    return new Promise(resolve => {
        setTimeout(() => resolve(n + 200), n);
    });
}//这里没有使用async是因为这个函数一开始就是Promise，不用再进行转换了

function step1(n) {
    console.log(`step1 with ${n}`);
    return takeLongTime(n);
}

function step2(n) {
    console.log(`step2 with ${n}`);
    return takeLongTime(n);
}

function step3(n) {
    console.log(`step3 with ${n}`);
    return takeLongTime(n);
}

//现在用 Promise 方式来实现这三个步骤的处理
function doIt() {
    console.time("doIt");
    const time1 = 300;
    step1(time1)
        .then(time2 => step2(time2))
        .then(time3 => step3(time3))
        .then(result => {
            console.log(`result is ${result}`);
            console.timeEnd("doIt");
        });
}

doIt();
// c:\var\test>node --harmony_async_await .
// step1 with 300
// step2 with 500
// step3 with 700
// result is 900
// doIt: 1507.251ms



//用 async/await 来实现
async function doIt() {
    console.time("doIt");
    const time1 = 300;
    const time2 = await step1(time1);
    const time3 = await step2(time2);
    const result = await step3(time3);
    console.log(`result is ${result}`);
    console.timeEnd("doIt");
}
doIt();
```

结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是**==清晰得多==**，**==几乎跟同步代码一样==**



例子2：

```javascript
function takeLongTime(n) {
    return new Promise(resolve => {
        setTimeout(() => resolve(n + 200), n);
    });
}

function step1(n) {
    console.log(`step1 with ${n}`);
    return takeLongTime(n);
}

function step2(m, n) {
    console.log(`step2 with ${m} and ${n}`);
    return takeLongTime(m + n);
}

function step3(k, m, n) {
    console.log(`step3 with ${k}, ${m} and ${n}`);
    return takeLongTime(k + m + n);
}

//这回先用 async/await 来写
async function doIt() {
    console.time("doIt");
    const time1 = 300;
    const time2 = await step1(time1);
    const time3 = await step2(time1, time2);
    const result = await step3(time1, time2, time3);
    console.log(`result is ${result}`);
    console.timeEnd("doIt");
}

doIt();
// c:\var\test>node --harmony_async_await .
// step1 with 300
// step2 with 800 = 300 + 500
// step3 with 1800 = 300 + 500 + 1000
// result is 2000
// doIt: 2907.387ms


//写成 Promise 方式
function doIt() {
    console.time("doIt");
    const time1 = 300;
    step1(time1)
        .then(time2 => {
            return step2(time1, time2)
                .then(time3 => [time1, time2, time3]);
        })
        .then(times => {
            const [time1, time2, time3] = times;
            return step3(time1, time2, time3);
        })
        .then(result => {
            console.log(`result is ${result}`);
            console.timeEnd("doIt");
        });
}
doIt();
```

有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— **==参数传递太麻烦了==**，看着就晕！



## 为什么async是Generator语法糖







## 箭头函数

见笔记



## ==JavaScript运行机制==

单线程、解释性语言

事件循环

宏任务、微任务



### 进程与线程

**==线程==**：是进程里的一个独立的执行单元，是程序执行的一个完整流程，是cup调度的最小单元，一个程序至少有一个运行的线程，这个线程成为**==主线程==**（进程启动后自动创建）

一个进程里的数据可供多个线程直接共享

多个进程之间数据时不能直接共享的（进程间的内存是相互独立的）

**==线程池( thread pool)==**：保存多个线程对象的容器，**<font color='red'>实现线程对象的反复利用</font>**

**==单线程==**：**<font color='red'>一个进程里面有一个线程在运行，则这一个程序是单线程的程序</font>**

**==多线程==**：一个进程里面有多个线程在运行，则这一个程序是多线程的程序

![image-20210513184656713](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513184656713.png)





最一开始js是单线程运行的，但在html5里面Web Workers可以多线程运行

浏览器是多线程运行的，但有的浏览器时多进程运行，有的是单进程运行

![image-20210513185415507](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513185415507.png)



### 浏览器内核

![image-20210513185542226](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513185542226.png)



> 下各常用浏览器所使用的内核。 
> 1、IE浏览器内核：Trident内核，也是俗称的IE内核； 
> 2、Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核； 
> 3、Firefox浏览器内核：Gecko内核，俗称Firefox内核； 
> 4、Safari浏览器内核：Webkit内核； 
> 5、Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核； 
> 6、360浏览器、猎豹浏览器内核：IE+Chrome双内核； 
> 7、搜狗、遨游、QQ浏览器内核：Trident（兼容模式、涉及到支付的时候可以使用）+Webkit（高速模式）； 
> 8、百度浏览器、世界之窗内核：IE内核； 
> 9、2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；



内核由很多模块组成

![image-20210513204551285](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513204551285.png)

### 定时器引发的思考

![image-20210513205130668](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513205130668.png)

![image-20210513205302076](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513205302076.png)

上面的内容是绑定在一个按钮的回调函数，通过两个Date.now相减，得到定时器延时的真正时间，发现比200毫秒长不少

**<font color='red'>这是为什么呢</font>**

### js是单线程的

**==为什么js要用单线程模式，而不用多线程模式==**

Javascript的单线程，与它的用途有关。

作为脚本语言， Javascript，的主要用途是与用户互动，似及操作DOM

这决定了它只能单线程，否则会带来很复杂的同步问题（比如两个线程想要操控同一个元素，就会产生冲突）



**==代码的分类：==**

​	初始化代码

​	回调代码



**==js代码执行的基本流程==**

①先执行初始化代码：包含一些特别的代码，如下

​		设置定时器

​		绑定监听函数

​		发送ajax请求

②后面在某个时刻才会执行回调代码（这就解释了上面的例子）

### ==事件循环模型==

![image-20210513220034828](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513220034828.png)

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513221657117.png" alt="image-20210513221657117" style="zoom:67%;" />

模型的运转流程：

​	①执行**==初始化代码==**，将事件回调函数交给对应模块管理

​	②当事件发生时，**==管理模块（定时器、DOM、Ajax）==**会将回调函数及其数据添加到**==回调队列==**中

​	③只有当初始化代码执行完成之后（可能要一段时间），才会遍历读取**==回调队列==**中的回调函数执行

> 网上另一种解释：
>
> **JS执行是单线程的，它是基于事件循环的。**
>
> 1. 所有同步任务都在主线程上执行，形成一个执行栈。
> 2. 主线程之外，会存在一个任务队列，只要异步任务有了结果，就在任务队列中放置一个事件。
> 3. 当执行栈中的所有同步任务执行完后，就会读取任务队列。那些对应的异步任务，会结束等待状态，进入执行栈。
> 4. 主线程不断重复第三步。

图中的==**event loop**==就是**==事件轮询==**：从任务队列中循环取出回调函数放入执行栈中处理（一个接一个）

![image-20210513221850358](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513221850358.png)





### ==宏任务和微任务==

![image-20210513204551285](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513204551285.png)

之前讲的程序中设置**==两个线程==**：

**<font color='red'>主线程：初始化执行代码（同步任务）</font>**：包含绑定dom事件监听，设置定时器，发送ajax请求的代码

<font color='red'>**分线程/消息线程：回调执行代码（异步任务）**</font>：处理回调逻辑

--------------------------------------------------------------------

<font color='red'>**！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！注意注意注意**！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</font>:请记得之前我们讲的将定时器、ajax、promise这些操作的**执行、绑定、设置阶段**放在了主线程：初始化代码，而将**他们的回调函数**放在了分线程

下面网上讲解跟之前的有出入，下面引入宏任务的时候**==将定时器、ajax、promise这些操作的执行、绑定、设置阶段放在了宏任务里面==**，我们知道，宏任务是属于异步任务的

> 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。**这里把回调函数都当成了异步任务**

---------------------------------------------------



**<font color='red'>异步任务</font>**分为**==宏任务==**和**==微任务==**

**==微任务先执行，宏任务后执行==**

![image-20210518204853081](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210518204853081.png)

**==宏任务有以下：==**

​		新程序或子程序被直接执行（指script）

​		事件的回调函数

​		计时器的回调：setTimeout()、setInterval()

**==微任务有以下：==**

​		Promise. then().catch(). finally()

​		MutationObserver

​		Obiect.observe



ES6 规范中，宏任务：**==macrotask 称为 `task`==**，微任务：**==microtask 称为 `jobs`==**

**==宏任务==**是由**宿主**发起的，而**==微任务==**由**JavaScript自身**发起，不需要浏览器，JavaScript引擎自身也能够发起异步任务

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210518210047415.png" alt="image-20210518210047415" style="zoom:80%;" />

**==例子1：==**

![image-20210518194737671](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210518194737671.png)

![image-20210518194829390](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210518194829390.png)

![image-20210518194924774](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210518194924774.png)





**==例子2：==**

```javascript
console.log('start')

setTimeout(() => {
  console.log('setTimeout')
}, 0)

new Promise((resolve) => {
  console.log('promise')
  resolve()
})
  .then(() => {
    console.log('then1')
  })
  .then(() => {
    console.log('then2')
  })

console.log('end')
/*输出结果：
start 
promise
end
then1
then2
setTimeout
*/
```







### HTML5 Web Workers多线程

Web Workers是HTML5提供的一个 javascript多线程解决方案

我们可以将一些大计算量的代码交由 web Worker运行**==而不冻结用户界面==**，也就是交给**==子线程==**去运行

但是子线程完全受主线程控制，且**==不得操作DOM.==**

所以，**<font color='red'>这个新标准并没有改变 Javascript单线程的本质</font>**



例子：

设计一个点击事件，回调函数进行递归计算菲波那切数列

![image-20210513225100821](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513225100821.png)

但是这个操作有一个问题：当点击按钮开始计算时，如果输入的数字大一点，界面就会卡住，因为函数开始计算后，原先的js只有单线程，等到计算结束后，才能再次操作界面

为解决这个问题，可以使用Web Workers，将计算的步骤放到分线程中去计算，主线程仍然可以操作界面

这里不过于深究Web Workers的写法

新建一个worker.js文件，用来存放回调函数中的就按内容，作为分线程的操作

![image-20210513230320680](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513230320680.png)

主线程中的操作，也就是原来html文件中的代码如下，在回调函数中创建Worker对象，向分线程中发送消息，并且绑定从分线程中过来的消息监听（截图中这两步的顺序颠倒了，但是无所谓，因为回调函数总是在初始代码执行完才执行）

![image-20210513230151458](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210513230151458.png)







## 实现继承的方式

### 原型链继承

#### 接用构造函数继承

#### ==组合继承==

#### ==es6中class类使用extends关键字继承==

## 垃圾回收

https://zhuanlan.zhihu.com/p/23992332

**<font color='red'>常见的内存泄露</font>**：

​	①意外的全局变量，比如：在函数里面定义全局变量，导致执行环境无法清除

​	②没有及时清理的计时器(**setTimeout setInterval**)或回调函数

​	③对闭包的使用导致无法清除

​	④循环引用，函数中虽然没有全局变量，但是下面这个函数有两个对象互相引用，导致垃圾回收的时候不能清除这种还有引用的对象（解决方法：在函数中手动将其置空）

```javascript
function func() {
    let obj1 = {};
    let obj2 = {};

    obj1.a = obj2; // obj1 引用 obj2
    obj2.a = obj1; // obj2 引用 obj1
}
```





## ==回流(重排)与重绘==

### ==浏览器的渲染过程==

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210515101339545.png" alt="image-20210515101339545" style="zoom:80%;" />

1. 先解析HTML，生成**==DOM树==**，然后解析CSS，生成**==CSSOM树==**
2. 将DOM树和CSSOM树结合，生成**==渲染树==**(Render Tree)
3. **==Layout(回流)==**:根据生成的渲染树，进行回流(Layout)，得到**==节点的几何信息==**（位置，大小）
4. **==Painting(重绘)==**:根据渲染树以及回流得到的几何信息，得到**==节点的绝对像素==**
5. Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开）



> **==网上另一种描述：==**
>
>   浏览器渲染引擎工作流程都差不多，大致分为5步，**创建DOM树——创建StyleRules——创建Render树——布局Layout——绘制Painting**
>
>   第一步，用HTML分析器，分析HTML元素，**构建一颗DOM树**(标记化和树构建)。
>
>   第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。
>
>   第三步，将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。每个DOM节点都有**attach方法，接受样式信息**，返回一个render对象(又名renderer)。这些render对象最终会被构建成一颗Render树。
>
>   第四步，有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。
>
>   第五步，Render树和节点显示坐标都有了，就调用每个节点**paint方法，把它们绘制**出来。 



#### 生成渲染树

![image-20210515112059614](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210515112059614.png)

为了构建渲染树，浏览器主要完成了以下工作：

1. 从DOM树的根节点开始遍历每个**==可见节点==**。
2. 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。
3. 根据每个可见节点以及其对应的样式，组合生成渲染树。

第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：

- **==一些不会渲染输出的节点==**，比如script、meta、link等。
- **==一些通过css进行隐藏的节点==**。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。

**注意：渲染树只包含可见的节点**



### 回流与重绘

回流：前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的**==确切位置和大小==**，这个**==计算的阶段就是回流==**。

重绘：最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以**==将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。==**

### 何时发生回流重绘

我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当**==页面布局和几何信息发生变化==**的时候，就需要**==回流==**。比如以下情况：

- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
- 页面一开始渲染的时候（这肯定避免不了）
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

**<font color='red'>注意：回流一定会触发重绘，而重绘不一定会回流</font>**

根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。



### 浏览器的优化机制

现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！**当你获取布局信息的操作的时候，会强制队列刷新**，比如当你访问以下属性或者使用以下方法：

- offsetTop、offsetLeft、offsetWidth、offsetHeight
- scrollTop、scrollLeft、scrollWidth、scrollHeight
- clientTop、clientLeft、clientWidth、clientHeight
- getComputedStyle()
- getBoundingClientRect



> 思考以下代码将会触发几次渲染？
>
> ```javascript
> div.style.left = '10px';
> div.style.top = '10px';
> div.style.width = '20px';
> div.style.height = '20px';
> ```
>
> 根据我们上文的定义，这段代码**==理论上==**会触发4次重排+重绘，因为每一次都改变了元素的几何属性，**==实际上==**最后只触发了**==一次重排==**，这都得益于浏览器的**渲染队列机制**：
>
> 当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了**一定的数量或者到了一定的时间间隔**时，浏览器就会批量执行这些操作。



### 如何减少回流和重绘

https://segmentfault.com/a/1190000017329980/

#### 最小化重绘和重排

#### 批量修改DOM

#### 避免触发同步布局事件

#### 对于复杂动画效果,使用绝对定位让其脱离文档流

### css3硬件加速（GPU加速）

常见的触发硬件加速的css属性：

- transform
- opacity
- filters
- Will-change

**划重点：使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。**









## id属性和name属性的区别

### **html中的id属性**

我们使用id属性可以标识唯一的HTML元素，可以在在URL中用作锚引用（带#符号的URL），或者在css中用作ID选择器来设置该元素的样式。也可以在javascript中，使用getElementById()，通过id属性值来查找元素，在对元素进行操作。例：

```html
<p id="p1">测试文本！测试文本！</p>
<p id="p2">测试文本！测试文本！</p>
```

![img](https://pic4.zhimg.com/80/v2-15cdfa659f194047f6357d559957f637_720w.jpg)

```html
<script>
document.getElementById("p2").style.color="red";
</script>
```

![img](https://pic1.zhimg.com/80/v2-77791ba2a91bac5de9cd622efafa33a0_720w.jpg)

id属性是普遍兼容的，对任何元素都有效。且id属性的值是区分大小写的，每个id值都应该是唯一的。例：

```html
<div id="demo">
 <div id="a">div标签，id值为a</div>
 <p id="A">p标签，id值为A</p>
</div>
```



```css
#a{ color: red;}
#A{ color: pink;} 
```

**效果图：**

![img](https://pic2.zhimg.com/80/v2-a2344c596fab43c5dab168f662aa7be9_720w.jpg)

### **html中的name属性**

name属性同样是用来标识HTML元素的，但它不具有是唯一行，它的值可以重复使用，例：单选按钮

```html
<form action="" method="get"> 
 最喜欢水果？<br /><br /> 
 <label><input name="Fruit" type="radio" value="" />苹果 </label> <br /> 
 <label><input name="Fruit" type="radio" value="" />桃子 </label> <br /> 
 <label><input name="Fruit" type="radio" value="" />香蕉 </label> <br /> 
 <label><input name="Fruit" type="radio" value="" />梨 </label> <br /> 
 <label><input name="Fruit" type="radio" value="" />其它 </label> <br /> 
</form>
```

**效果图：**

![img](https://pic1.zhimg.com/80/v2-27eb73c5c6c5488c4d5e7624831b8b7c_720w.jpg)

正如上例所示，name属性经常在表单中使用，用来提交信息；它仅对a, form, iframe, img, map, input, select, textarea等标签元素有效。

name属性可以在在javascript中，使用getElementsByName()来查找元素；但无法在CSS或URL中被引用。例：

```html
<script type="text/javascript">
function getElements()
 {
 var x=document.getElementsByName("myInput");
 alert(x.length);
 }
</script>
 
 
<input name="myInput" type="text" size="20" /><br />
<input name="myInput" type="text" size="20" /><br />
<input name="myInput" type="text" size="20" /><br />
<br />
<input type="button" onclick="getElements()" value="名为 'myInput' 的元素有多少个？" />
```

**效果图：**



![img](https://pic3.zhimg.com/v2-22677f5f908fe343e23bedeaaa72ef8a_b.webp)



**说明：** 

可以这样说，ID是一个人的身份证号码，而Name是这个人的名字。两者可以同时存在，共享相同的命名空间（两者的值可以相同）。











## 锚













## es6







##  修改this指向 

> 封装函数 f，使 f 的 this 指向指定的对象。

这里给出三种写法，哪种都可以。

```js
// apply修改this作用域
function bindThis(f, oTarget) {
    return function (){
        return f.apply(oTarget,arguments)
    }
}

// call修改this作用域
function bindThis(f, oTarget) {
    return function (){
        return f.call(oTarget,...arguments)
    }
}
// bind修改this作用域
function bindThis(f, oTarget) {
    return function (){
        return f.bind(oTarget,...arguments)()
    }
}
// 或者直接简写
function bindThis(f, oTarget) {
    return f.bind(oTarget)
}
```

相关知识点：

1. apply、call、bind区别

> apply、call、bind的作用都是修改执行上下文
>
> apply、call都是返回函数立即执行的结果，其中apply第二个参数之后是数组，call、bind第二个参数之后是单个的值。
>
> bind返回的是函数，需要手动执行结果。第二个参数之后是单个的值。





## ==setTimeout在死递归的时候不会堆栈溢出==

```javascript
function foo() {
    foo(); //执行1000次左右会发生堆栈溢出的错误， 
    //setTimeout(foo, 0); //永远不会堆栈溢出
  }
 foo()
```

setTimeout 是**==伪异步执行==**的,你把函数交给setTimeout处理后,**==原来的函数不会等待,会继续执行==**,函数能够结束,资源也就可以释放

而不用setTimeout的时候,函数必须等待调用的函数返回后才能继续执行,但调用的函数又必须等待下一极函数......这样所有函数都不能结束,资源就一直不释放,故溢出





## 继承













## web页面加载的过程









## 求数组最大值

在使用Math.max()求数组的最大值时，ES5可以通过 apply 做到（用一种不友好且繁琐的方式）

```js
// ES5 apply 写法
var array = [1,2,3,4,3];
var max1 = Math.max.apply(null,array);
console.log(max1);//4
```

幸运的是JavaScript的世界在不断改变，扩展运算符可用于数组的析构，优雅的解决了这个问题。

```js
// ES6 扩展运算符 写法
var array = [1,2,3,4,3];
var max2 = Math.max(...array);  
console.log(max2);//4
```

先把 array 打散成 1 2 3 4 3，再在里面找最大的那一个，就显而易见了。



## 将arguments转化为数组

```javascript
// arguments变量的写法,将arguments转化为数组，然后用sort进行排序
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法，将arguments转化为数组，并进行排序
const sortNumbers = (...numbers) => numbers.sort();
```



## rest运算符与扩展运算符的区别

rest运算符放在函数声明的形参的位置

扩展运算符可以放在函数调用的实参的位置

## rest参数与arguments对象的区别



## 数组合并的方法



## ==class类==



## 对象数组解构的方法



## 原型















## 数组去重

利用set集合

![image-20210420220127332](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210420220127332.png)

方法汇总：

https://segmentfault.com/a/1190000016418021?utm_source=tag-newest





## 取消事件冒泡









## pushState()与replaceState()













## querySelectorAll 和getElementsByClassName的区别

querySelectorAll 返回的是映射 **==改变其值不会改变document==**

而getElementsByClassName **==改变它就会改变document==**

在js里面querySelector()选择的标签是静态的
也就是说在选中之后，能够一直保存，也就是脱离了被选择的成为副本，除非是要保存选中的标签，否则不会轻易地使用querySelector()。

在js里面getelementsByClassName()选择的标签是动态的，所以是相互映射，在调用时，我们一般使用这种标签，因为可以及时的反映在页面上。

















## ajax和axios对比







## Array.prototype.slice.call(arguments,0)

将类数组对象转换为一个真正的对象







# ==----------------------------==


# vue

## $的作用

$ref, $on, $mount等等也都是以”$”开头。

**<font color='red'>虽然属性名上添加前缀不是必须的，但是这样做可以提醒糊涂的开发人员（可能是你）</font>**，**==这是一个公共API属性或方法，欢迎你使用，不像其他属性的实例，可能只是为了 Vue 的内部使用。==**

作为基于原型的语言，Javascript 中没有（真正的）类，因此也没有 “私有” 和 “公共” 变量或 “静态” 方法。 这个惯例是一种很好的替代品，我们认为是值得遵守的约定。





## 跨域







## 生命周期









## webpack和gulp的对比







## 监听组件根元素的元原生事件





## 为什么组件中的data必须是一个函数











## runtime-only和runtime-compiler的区别









## 前端渲染后端渲染/前端路由后端路由











## url的结构











## $的作用

除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 `$`，以便与用户定义的 property 区分开来。例如：









## vue的动态代理







## 单页面应用（SPA）

只有一张web页面的应用，是一种从web服务器加载的富客户端。

​    单页面跳转仅刷新局部资源，公共资源仅刷新一次，之后的操作交互，数据交互是通过路由、ajax来进行的，页面本身没有进行刷新。

​     **==优点：==**

​          ①前后端分离

​           ②良好的交互体验——用户不用刷新页面，页面显示流畅

​           ③减轻服务器压力——服务器只出数据

​           ④共用一套后端代码——多个客户端可共用一套后端代码

​     **==缺点：==**

​          ①seo难度高——数据渲染在前端进行，seo主要是让网站对于搜索引擎的爬虫更加友好，spa页数据动态生成，爬虫识别不了

​           ②前进后退管理——单页面不能使用浏览器的前进后退，页面切换要自己建立堆栈管理，解决方法：利用url的散列+iframe实现

​           ③初次加载耗时长

​			④页面复杂度提高很多



### 比较单页应用和多页应用

多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新

![img](https://images2018.cnblogs.com/blog/1013869/201804/1013869-20180413214226425-113139192.png)



## MVVM

见笔记



**<font color='red'>MVVM和mvc、mvp等等都是框架模式，都是为了解决代码分层、职责划分的问题，解决model和view耦合的问题，解决维护性问题</font>**



**==mvc==**出现较早，最一开始是在后端，后来在前端领域也有应用，虽然分层了，但是为了开发灵活性，导致数据流混乱，维护性变差

**==mvp==**是mvc的进化，将control层改为presenter层，presenter层作为model和view层双向交互的桥梁，但是一旦应用变得很大，presenter层就变得异常臃肿，难以维护

**==mvvm==**模式不仅能解决MV层耦合问题，还同时减少了之前p层中大量的代码（之前vm这两层为了映射、修改数据后进行dom操作，需要大量代码），现在有了数据响应式，这些操作不需要我们自己去做，性能较好











## ==Vue的响应式原理（数据的双向绑定）==

提示：教程中使用webpack来管理代码，因为在后续程序编写过程中，会频繁的暴露一些接口，并且基于模块化开发，需要webpack来管理一些依赖

### 数据改变的侵入式和非侵入式

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210515195251848.png" alt="image-20210515195251848" style="zoom:80%;" />

在vue中，像我们在方法中改变data中的数据时，直接this.数据进行改变就行了，这种方法叫做**==非侵入式==**

但是像例子中，react和小程序中改变数据，都需要调用固定的方法才能改变，这种叫做**==侵入式==**

侵入式数据的改变就比较容易理解，**调用的这个方法中已经封装好了可以修改数值的操作，并且也封装好了修改dom值的操作**，做到响应式

但是vue中是直接修改data值就行，下面就讲一下vue中数据响应式是怎么实现的



### Object.defineProperty()方法

可以做数据劫持和数据代理

是js本身具有的方法，从ie8开始兼容，利用js引擎检测对象属性的变化

**==作用：==**

Object.defineproperty（）方法会直接在一个对象上**==定义一个新属性==**，或者**==修改一个对象的现有属性==**，并**==返回此对象==**。

该方法有**三个参数**，

​	第一个：要修改的对象，

​	第二个：属性名，是字符串

​	第三个：一个对象，对象里面有各种属性，分别用来设置这个属性的一些特性，其中用**==value==**来设置属性的值

```javascript
var obj = {};
Object.defineProperty(obj, 'a', { 
value: 3
});
Object.defineProperty(obj, 'b', { 
value: 5
});
console.log(obj); 
console.log(obj.a, obj.b);
```



 Object.defineProperty()方法可以设置一些**==额外隐藏的属性==**，方便这个属性更加自由的被定义

```javascript
Object.defineProperty(obj, 'a', { 
value: 3,
// 是否可写
writable: false
});

Object.defineProperty(obj, 'b', {
value: 5,
// 是否可以被枚举
enumerable: false
});
```



#### getter/setter

此概念之前反复提到过，这个是在Object.definePropert方法中第三个参数中的属性，**==get和set属性值都是一个函数（方法）==**，在对应的时刻调用

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210515212410198.png" alt="image-20210515212410198" style="zoom:80%;" />

get属性和value属性不能同时出现，

但是如果某个属性没有设置value，就认为当前对象的这个属性不存在

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210515213309398.png" alt="image-20210515213309398" style="zoom:80%;" />

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210515213337126.png" alt="image-20210515213337126" style="zoom:80%;" />

**==可以通过如下方法设置，也就是get函数的返回值就是读取属性时的属性值==**

```js
// 在对象中添加一个属性与存取描述符的示例
var bValue;
var o = {};
Object.defineProperty(o, "b", {
  get : function(){
    console.log('监听正在获取b')
    return bValue;
  }
});
```

之前说过vue数据响应直接修改数据就可以，用的就是这个get和set，这两个函数可以劫持到数据修改和数据读取

### defineReactive函数

下面是一个Object.defineProperty()方法的例子

```javascript
var temp;
Object.defineProperty(obj, 'a', {
    // getter 
    get() {
        console.log('你试图访问obj的a属性'); 
        return temp;
    },
    // setter 
    set(newValue) {
        console.log('你试图改变obj的a属性', newValue); 
        temp = newValue;
    }
});
```

**<font color='red'>这就意识到一个问题，getter/setter需要变量周转才能工作</font>**，**==例子中的temp==**，有了这个temp，属性的读取、赋值才能正常使用，不然修改后的值不能实时地反映到get函数中，导致每次修改完属性后，再次读取属性发现没改过去

所以说Object.defineProperty()并不太好用



所以要自定义一个defineReactive函数，写法如下

其实就是将Object.defineProperty方法放进了这个函数

**<font color='red'>这样方便了一个操作：不用再在外部定义用于周转的变量了，做了一个封装</font>**

这里利用的其实是**==闭包==**，defineReactive函数三个参数，**==对象名、属性名、属性值==**

在使用defineReactive函数时，可以给某个对象的某个属性**==赋初始值==**，**defineReactive(obj, a, 10)** ，**<font color='red'>也可以不用第三个属性（函数中已经加上了有无第三个参数的判断）</font>**，这样仅仅为a属性加上了可枚举、可修改、set、get这些属性

但参数中的属性值更重要的作用是给函数中的Object.defineProperty方法提供了一个周转变量

```javascript
function defineReactive(data, key, val) {
    //如果不传入第三个参数的话，直接等于原来的值，不写这个的话，省略第三个参数时原来的属性值会变成undefined
    if(arguments.length===2){
				val=data[key];
			}
    Object.defineProperty(data, key, {
        // 可枚举
        enumerable: true,
        // 可以被配置，比如可以被delete
        configurable: true,
        // getter 
        get() {
            console.log('你试图访问obj的' + key + '属性'); 
            return val;
        },
        // setter
        set(newValue) {
            console.log('你试图改变obj的' + key + '属性', newValue);
            if (val === newValue) {
            return;
        	}
        val = newValue;
        }
    });
}
```



### 递归侦测对象全部属性

![image-20210516184113651](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210516184113651.png)

```javascript
var obj = { 
    a: {
        m: {
            n: 5
        }
    },
    b: 4
};
```

当对象中的属性中仍嵌套着属性时，**==嵌套的属性上面并没有使用defineReactive函数==**，也就是嵌套的属性里面并没有set和get，而且嵌套的属性上想要使用Object.defineProperty()还使用不了，因为这个方法第二个参数是一个字符串，嵌套的属性如：a.m.n，**==字符串也不能识别这个小数点==**







这时候需要创建一个类：Observer类，这个类是用来将一个不同的object对象转换为其每一层属性都是响应式的类

在对象中还要添加一个**\_\_obj\__属性**，这个**类的实例**需要作为**\_\_obj__属性的属性值**

对象中有无\_\_obj\__属性可以当做对象（在后面对嵌套属性遍历的时候，属性也会充当这里对象的角色）**有无做到响应式的标志**

在写这个Observer类之前，我们还需要创建一个函数：**observe函数**，这个函数是用来辅助判别的，也就是判断对象或属性中有没有\_\_obj\__属性，没有的话就新建一个Observer实例对象

**==observe.js：==**

```javascript
import Observer from './Observer.js';
export default function (value) {
    // 如果value不是对象，什么都不做
    if (typeof value != 'object') return;
    // 定义ob
    var ob;
    if (typeof value.__ob__ !== 'undefined') {
        ob = value.__ob__;
    } else {
        ob = new Observer(value);//这一步是为了在value对象上面添加__ob__属性，属性值是new的这个Observer实例本身（这一点可以从utils.js文件中看出），这个Observer类的实例中会有实现将所有属性做到响应式的方法（也就是自定义walk方法进行遍历，使每一个父级属性都使用defineReactive函数，defineReactive内部也进行了修改，将defineReactive函数的第三个参数，也就是属性值，再使用一次observe函数，又进行了一遍上面的步骤，形成了递归）
    }
    return ob;
}
```

下面就来看Observer.js中Observer类的编写

Object中需要利用**defineProperty方法**，为指定对象（或者属性）添加一个\_\_obj\__属性，属性值是这个Observer实例对象本身

我们可以将这一步封装起来，封装成一个**def()函数**，放在**utils.js文件**中，

**==utils.js文件==**如下：

```javascript
export const def = function (obj, key, value, enumerable) {
	// 封装了一个方法，主要用来为指定对象（或者属性）添加一个__obj__属性，属性值是这个Observer实例对象本身
    Object.defineProperty(obj, key, {
        value,
        enumerable,
        writable: true,
        configurable: true
    });
};
```



然后我们需要自定义一个**walk函数**，来遍历当前对象（或者属性）中的属性，为每一个属性使用defineReactive()函数，来做到响应式

**==Observer.js文件==**如下

```javascript
import { def } from './utils.js';
import defineReactive from './defineReactive.js';

export default class Observer {
    constructor(value) {
    // 给实例（this，一定要注意，构造函数中的this不是表示类本身，而是表示实例）添加了__ob__属性，值是这次new的实例
    def(value, '__ob__', this, false);//在value（index.js中输入的obj）对象上创建__obj__属性，属性值是ob（一个Observer实例），且该属性是不可枚举的
    // console.log('我是Observer构造器', value);
    this.walk(value);
    }
    // 遍历
    walk(value) {
        for (let k in value) {
            defineReactive(value, k);
        }
    }
};
```



这时候defineReactive函数中只能做到一层的属性实现响应式，嵌套的属性仍然不能实现响应式

**这时候就需要将defineReactive函数的第三个参数，也就是属性值，再使用一次observe函数**，又进行了一遍上面的步骤，形成了递归

并且如果属性的值不是一个属性，也没关系，在observe中已经进行了判断

如果设置了新的值，在下面的set方法中也要使用一次observe函数，进行递归

而且**不用担心死循环**，因为肯定会有属性的值不再是属性，不在有嵌套关系通过observe中的if判断，**就中断了递归**

**==defineReactive.js==**文件如下

```javascript
import observe from './observe.js';
import Dep from './Dep.js';

export default function defineReactive(data, key, val) {
    const dep = new Dep();
    // console.log('我是defineReactive', key);
    if (arguments.length == 2) {
        val = data[key];
    }
    /* 关键步骤：子元素要进行observe，至此形成了递归。
		这个递归不是函数自己调用自己，而是多个函数、类循环调用
		 并且如果属性的值不是一个属性，也没关系，在observe中已经进行了判断
		 如果设置了新的值，在下面的set中也要进行递归
		 而且不用担心死循环，因为肯定会有属性的值不再是属性，不在有嵌套关系通过observe中的if判断，就中断了递归*/
    let childOb = observe(val);

    Object.defineProperty(data, key, {
        // 可枚举
        enumerable: true,
        // 可以被配置，比如可以被delete
        configurable: true,
        // getter
        get() {
            console.log('你试图访问' + key + '属性');
            return val;
        },
        // setter
        set(newValue) {
            console.log('你试图改变' + key + '属性', newValue);
            if (val === newValue) {
                return;
            }
            val = newValue;
            // 当设置了新值，这个新值也要被observe
            childOb = observe(newValue);
        }
    });
};
```

至此，属性中嵌套的属性都能做到响应式了



### 数组的响应式处理

现在的响应式处理是不能处理数组的，比如对象属性的值是一个数组，便没有响应式的效果

为此vue改写了数组的七个方法，也就是能让数组发生改变的7个方法

• push

• pop 

• shift 

• unshift 

• splice 

• sort 

• reverse

这七个方法都是在**==Array.prototype==**上的，所有数组中可以通过**==.小数点==**调用的方法都是Array.prototype上的



**==想要实现的效果：==**

使用数组方法时，上面那七个方法用我们自己改写的，其他方法仍用原来的

**==思路：==**

①首先我们要创建一个对象arrayMethods，这个对象要**以Array为原型**，也就是arrayMethods.proto = Array.prototype

②**在arrayMethods中改写这七个数组方法**

③**然后我们尝试将数组数据（指的是数据，并不是Array）的原型改为arrayMethods**，原来是Array

这样我们在使用数组方法的时候，这7个方法会优先使用我们自定义的，别的会在原型链上查找，找到Array.prototype上定义的其他方法



**改写某个对象原型的方法有两种**：

​	Object.setPrototypeOf(数组, arrayMethods)  

​	数组.\_\_obj\__ = arrayMethods

**以某个对象为原型创建对象的方法：**

Object.create(Array.prototype)

此方法参数为对象的原型



创建array.js文件，在array.js文件中复制一下Array.prototype原型，然后在此基础上将7个方法进行修改，然后再将这个修改后的原型暴露出去，Observer..js中，将数组的原型指向这个

这里我们先看Observer.js文件中的改进

**==Observer.js==**文件如下

```javascript
import { def } from './utils.js';
import defineReactive from './defineReactive.js';
import { arrayMethods } from './array.js';
import observe from './observe.js';
import Dep from './Dep.js';

export default class Observer {
    constructor(value) {
        // 给实例（this，一定要注意，构造函数中的this不是表示类本身，而是表示实例）添加了__ob__属性，值是这次new的实例
        def(value, '__ob__', this, false);//在value（index.js中输入的obj）对象上创建__obj__属性，属性值是ob（一个Observer实例），且该属性是不可枚举的
        // console.log('我是Observer构造器', value);
        // 不要忘记初心，Observer类的目的是：将一个正常的object转换为每个层级的属性都是响应式（可以被侦测的）的object
        // 检查它是数组还是对象
        if (Array.isArray(value)) {
            // 如果是数组，要非常强行的蛮干：将这个数组的原型，指向arrayMethods
            Object.setPrototypeOf(value, arrayMethods);
            // 让这个数组变的observe
            this.observeArray(value);
        } else {
            this.walk(value);
        }
    }
    // 遍历
    walk(value) {
        for (let k in value) {
            defineReactive(value, k);
        }
    }
    // 数组的特殊遍历,数组里面的值仍要遍历，以防数组中仍有属性对象之类的
    observeArray(arr) {
        for (let i = 0, l = arr.length; i < l; i++) {
            // 逐项进行observe
            observe(arr[i]);
        }
    }
};
```

之前是直接执行walk函数，但是现在，到这一步时先判断value是不是数组，不是的话执行walk，是的话就**==修改其原型==**，**==并且进行数组项的遍历，以防数组中仍有属性对象之类的==**，遍历的话不是walk，walk函数是所有操作中最后一步：添加响应式

这里应当从**==observe函数开始==**，让数组中的值把前面的流程再过一遍，我们又自定义了一个 **observeArray**函数来遍历数组项



然后，我们来讲array.js文件中7个方法进行修改的过程

在array.js文件中复制一下Array.prototype原型，然后在此基础上将7个方法进行修改，然后再将这个修改后的原型暴露出去

??????????????????????????????????????????????????????????????????????????????????????????

**==array.js==**文件如下

```javascript
import { def } from './utils.js';
// 得到Array.prototype
const arrayPrototype = Array.prototype;
// 以Array.prototype为原型创建arrayMethods对象，并暴露
export const arrayMethods = Object.create(arrayPrototype);
// 要被改写的7个数组方法
const methodsNeedChange = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
];
methodsNeedChange.forEach(methodName => {
    // 备份原来的方法，因为push、pop等7个函数的功能不能被剥夺
    const original = arrayPrototype[methodName];
    // 定义新的方法
    def(arrayMethods, methodName, function () {
        // 恢复原来的功能
        const result = original.apply(this, arguments);
        // 把类数组对象变为数组
        const args = [...arguments];
        // 把这个数组身上的__ob__取出来，__ob__已经被添加了，为什么已经被添加了？因为数组肯定不是最高层，比如obj.g属性是数组，obj不能是数组，第一次遍历obj这个对象的第一层的时候，已经给g属性（就是这个数组）添加了__ob__属性。
        const ob = this.__ob__;
        // 有三种方法push\unshift\splice能够插入新项，现在要把插入的新项也要变为observe的
        let inserted = [];
        switch (methodName) {
            case 'push':
            case 'unshift':
                inserted = args;
                break;
            case 'splice':
                // splice格式是splice(下标, 数量, 插入的新项)
                inserted = args.slice(2);
                break;
        }
        // 判断有没有要插入的新项，让新项也变为响应的
        if (inserted) {
            ob.observeArray(inserted);//利用Observer.js中定义的函数来对数组中每一项逐项进行observe
        }
        console.log('啦啦啦');
        return result;//一定要有返回值，数组原来的7个方法中有一些方法使用返回值的，return回去这样数组原来的方法才完善
    }, false);
});
```





### 依赖收集

• 需要用到数据的地方，称为依赖 

• Vue1.x，细粒度依赖，用到数据的**==DOM==**都是依赖； 

• Vue2.x，中等粒度依赖，用到数据的**==组件==**是依赖； (比如父子组件传值，就会产生依赖)

• **==在getter中收集依赖==**，**==在setter中触发依赖==**



把依赖收集的代码封装成一个**==Dep类==**，它专门用来管理依赖

**==每个Observer的实例， 成员中都有一个Dep的实例==**

**==Watcher==**是一个中介，数据发生变化时通过Watcher中转，通知组件

![image-20210517172208985](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210517172208985.png)

![image-20210517191732322](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210517191732322.png)



• 依赖就是Watcher。只有Watcher触发的getter才会收集依赖，哪个 Watcher触发了getter，就把哪个Watcher收集到Dep中。 

• Dep使用发布订阅模式，当数据发生变化时，会循环依赖列表，把所 有的Watcher都通知一遍。 

• 代码实现的巧妙之处：Watcher把自己设置到全局的一个指定位置， 然后读取数据，因为读取了数据，所以会触发这个数据的getter。在 getter中就能得到当前正在读取数据的Watcher，并把这个Watcher  收集到Dep中。

**<font color='red'>Dep实例在Observer.js、defineReactive.js两个文件中创建</font>**

在**==Observer.js文件中==**创建Dep实例是为了将对象中所有对象属性添加上Dep实例，这个实例是存在于属性中的**==\_\_ob\_\_属性==**中的**==Observer实例==**中的**==dep属性==**，这个dep属性值是Dep实例（**我理解的是，在属性中添加这个实例的原因：为了在array.js文件中调用实例中的方法，因为在array.js文件中使用的方法是直接从自身的\_\_ob\_\_属性中调用的**）

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210517194449751.png" alt="image-20210517194449751" style="zoom:80%;" />

在**==defineReactive.js文件中==**使用Dep实例是为了在文件中的defineProperty函数中使用Dep中的方法（利用了闭包）

在**==array.js文件中==**使用Dep实例，直接从自身的\_\_ob\_\_属性中调用，不用导入



















## 组件中data为什么是函数

**<font color='red'>为什么data必须是一个函数：</font>**

多个相同的组件在调用时，使用的data中的数据并不是同一个对象，**==相互之间没有影响==**

多个地方引用data数据时，引用的而并不是一个，**==每次都是一个新的函数返回值==**，相当于每个地方重新调用函数，返回值相互之间没有关系



如果data直接是一个对象的话，每次使用的话都是同一个对象（访问的是同一个内存地址），这样就会产生错误

**所以data函数返回值千万不能返回一个在全局声明的一个obj对象**



## v-model的原理

v-model其实是一个语法糖，其背后有两个操作

​	①v-bind绑定一个value属性，绑定data中的变量

​	②v-on给当前元素绑定input事件，回调函数中将当前时间所在元素的value值赋值给data中的变量

原理实现例子：

![1617203922603](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\1617203922603.png)

文本框中的内容通过:value="message"来动态绑定data中的数据

文本框通过设置对input事件的监听，通过监听事件的返回函数来改变改data中的数据

其中input事件监听的改进

![1617204789927](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\1617204789927.png)





## v-if和v-show





## computed、watch和method

使用方法



### methods和computed区别

**==methods每调用一次就执行一次，而计算属性如果输入参数一样，浏览器会有computed的缓存，调用多次，只执行一次，效率更高==**

 当页面的数据变化时, methods中的方法会被重新调用(产生不必要的性能消耗), 而methods内的方法只有和自身有关的数据变化时才会被调用

**<font color='red'>computed只在初始化时被调用</font>**

**<font color='red'>methods会在数据变化时被调用, 即使变动的数据与自身无关</font>**



### computed和watch区别

**计算属性computed :** 

\1. **==支持缓存==**，只有依赖数据发生改变，才会重新进行计算

\2. **==不支持异步==**，当computed内有异步操作时无效，无法监听数据的变化

3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值

\4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed

5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

<img src="https://img2018.cnblogs.com/blog/1402448/201908/1402448-20190809154932198-1444047098.png" alt="img" style="zoom: 50%;" />

**侦听属性watch：**

\1. **==不支持缓存==**，数据变，直接会触发相应的操作；

2.watch**==支持异步==**；

3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；

\4. 当一个属性发生变化时，需要执行对应的操作；一对多；

\5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，

　　**==immediate==**：组件加载立即触发回调函数执行，

　　**==deep==**: 深度监听，为了发现**对象内部值**的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。

<img src="https://img2018.cnblogs.com/blog/1402448/201908/1402448-20190809160441362-1201017336.png" alt="img" style="zoom:50%;" />

监听的对象也可以写成字符串的形式

<img src="https://img2018.cnblogs.com/blog/1402448/201908/1402448-20190809160648619-505189772.png" alt="img" style="zoom:50%;" />

当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。这是和computed最大的区别，请勿滥用。





## Vue的生命周期

​	举例：哪个阶段能操作DOM：**==mounted阶段是最早可以操作dom的阶段==**

见笔记vue2.md的生命周期的钩子函数







### 父子组件生命周期的顺序

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210517151628014.png" alt="image-20210517151628014" style="zoom:67%;" />

由此得出，在父子组件第一次加载结束，整个父子组件生命周期为：父组件按顺序执行到beforeMounte，然后子组件开始执行beforeCreate到mounted这一过程，最后父组件再执行mounted到updated这个过程。

当父子组件存在通信的时候，子组件发生更新时，父子组件生命周期钩子函数执行情况

![image-20210517151803488](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210517151803488.png)

### vue路由中添加导航守卫的生命周期顺序

下面是销毁的时候父子组件之间生命周期钩子函数执行情况

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210517151944890.png" alt="image-20210517151944890" style="zoom: 80%;" />



vue中使用路由，添加导航守卫钩子函数后，生命周期钩子函数执行情况

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210519183400740.png" alt="image-20210519183400740" style="zoom: 50%;" />

## Vue组件间通信的方式

见笔记





## Vue单向数据流

数据从父组件传给子组件，只能单向绑定，子组件对父组件的数据只能访问不能修改。

父组件通过props传递数据给子组件，父组件是不能是直接访问子组件的数据的。





## keep-alive组件

keep-alive就是用来保留我们网页状态的一个组件

因为之前的每一个路由组件的打开与关闭都是一个生命周期

每次都会经历create()创建一个新的路由，在经过destroy()函数销毁，每次都是一个新的过程

keep-alive就相当于保持存活的意思 



**==keep- alive==**是**==Vue==**内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。

**==router-view==**是**==vue-router==**内置的一个组件，**如果直接被包在 keep- alive里面，所有路径匹配到的视图组件都会被存**





## Slot插槽









## Vue检测数组或对象的变化

### vm.$set()

全局Vue.set的别名

见笔记

博客：https://blog.csdn.net/weixin_43242112/article/details/108561587

### vm.$watch









## 虚拟Dom

### Virtual DOM 作用是什么？

**==虚拟DOM的最终目标是将虚拟节点渲染到视图上==**。但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的DOM操作。例如，一个ul标签下很多个li标签，其中只有一个li有变化，这种情况下如果使用新的ul去替代旧的ul,因为这些不必要的DOM操作而造成了性能上的浪费。

为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出真正需要更新的节点来进行DOM操作，从而**==避免操作其他无需改动的DOM。==**

### **虚拟dom的优点**

**==减少DOM操作：==**

①**虚拟DOM可以将多次操作合并为一次操作**。比如你添加1000个节点，原来是一个接一个操作的，利用虚拟dom可以将这1000个节点作为文本放在数组中，一次性将这1000个节点放在页面上

②**虚拟DOM借助 DOM diff可以把多余的操作省掉**，比如你想添加10个节点，原来的js操作没有办法区分哪些是新的，会多渲染很多东西，但是利用diff算法就可以只更新这10个节点

**==跨平台：==**

虚拟dom不仅可以变成dom，还可以变成小程序、iOS应用、安卓应用，因为虚拟dom本质上只是一个js对象



### 什么是虚拟dom？

一个能代表DOM树的对象，通常含有**标签名、标签上的属性、事件监听和子元素们**，以及其他属性

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210518170943826.png" alt="image-20210518170943826" style="zoom:80%;" />

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210518171017252.png" alt="image-20210518171017252" style="zoom:80%;" />

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210518171308587.png" alt="image-20210518171308587" style="zoom:80%;" />

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210518171542013.png" alt="image-20210518171542013" style="zoom:80%;" />

现在创建虚拟dom的方法跟我们创建正常的标签很像，但是不太一样，个别语法是不一样的

**==react框架==**的虚拟dom可以直接通过**==babel==**来将简便写法转换成原来的写法，是因为babel支持这种语法转换

但是**==vue==**不能直接通过babel来做这种转换（一是babel不支持vue的这种语法转换，二是vue也不是原生的js代码，vue用的是.vue文件，babel无法做转换），需要通过**==vue-router转换为h的形式==**

### 虚拟dom的缺点

需要额外的创建函数，如 createElement或h，但可以通过SX来简化成XML写法，然后通过打包工具转化为原来标准的写法（但是这么做也有不好的地方，就是依赖打包工具）



当数据规模是合理范围内，使用虚拟dom效果是比较好的，他能优化我们的操作，但当我们的操作达到一定程度（例如10万），原生的js性能最好，页面不会崩溃（但是这种情况一般也不会出现）







### diff算法

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210518180350668.png" alt="image-20210518180350668" style="zoom:67%;" />



<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210518181225954.png" alt="image-20210518181225954" style="zoom:67%;" />

![img](https://image.fundebug.com/2019-06-26-03.png)

Vue的diff算法是基于snabbdom改造过来的，**仅在同级的vnode间做diff，递归地进行同级vnode的diff，最终实现整个DOM树的更新**。因为跨层级的操作是非常少的，忽略不计，这样时间复杂度就从O(n3)变成O(n)。

diff 算法包括几个步骤：

- 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中
- 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
- 把所记录的差异应用到所构建的真正的DOM树上，视图就更新了

### diff算法的bug

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210518185154406.png" alt="image-20210518185154406" style="zoom:67%;" />

上面这个例子，第二个span标签v-if变成了false，新的虚拟dom就如图右边

这时候新旧对比的时候旧出现bug了，因为比不用虚拟dom都麻烦

这种情况下：

​		不用虚拟dom直接删除world的span

​		使用虚拟dom要先更新虚拟dom，然后对比不同，将hello改为world

#### :key的使用

:key一般就是指在v-for中使用

这样可以避免在修改（插入操作）这个循环遍历的元素时，产生的diff算法bug

**==不加的话==**，dom树和修改后的虚拟dom树进行对比，对比到有插入操作的这一个节点的地方，会进行修改，因为逐项对比的原因，后面节点对比时产生错位，所有的节点都需要修改

==加上的话==，diff算法会有一个标识，直接修改插入的这一个节点就可以了





## nextTick

### 什么是Vue.nextTick()？？

**==定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。==**

所以就衍生出了这个获取更新后的DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码；

**==理解：nextTick()，是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数，==**

```html
<template>
  <div class="hello">
    <div>
      <button id="firstBtn" @click="testClick()" ref="aa">{{testMsg}}</button>
    </div>
  </div>
</template>
 
<script>
export default {
  name: 'HelloWorld',
  data () {
    return {
      testMsg:"原始值",
    }
  },
  methods:{
    testClick:function(){
      let that=this;
      that.testMsg="修改后的值";
      console.log(that.$refs.aa.innerText);   //that.$refs.aa获取指定DOM，输出：原始值
    }
  }
}
</script>
 
```




使用this.$nextTick()

```javascript
  methods:{
    testClick:function(){
      let that=this;
      that.testMsg="修改后的值";
      that.$nextTick(function(){
        console.log(that.$refs.aa.innerText);  //输出：修改后的值
      });
    }
  }
```

注意：**Vue 实现响应式并不是数据发生变化之后 DOM 立即变化**，而是按一定的策略进行 DOM 的更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM

 

### 什么时候需要用的Vue.nextTick()

**==1、==**Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。

```javascript
  created(){
    let that=this;
    that.$nextTick(function(){  //不使用this.$nextTick()方法会报错
        that.$refs.aa.innerHTML="created中更改了按钮内容";  //写入到DOM元素
    });
  },
```



**==2、==**当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它

```html
<template>
  <div class="hello">
    <h3 id="h">{{testMsg}}</h3>
  </div>
</template>
 
<script>
export default {
  name: 'HelloWorld',
  data () {
    return {
      testMsg:"原始值",
    }
  },
  methods:{
    changeTxt:function(){
      let that=this;
      that.testMsg="修改后的文本值";  //vue数据改变，改变dom结构
      let domTxt=document.getElementById('h').innerText;  //后续js对dom的操作
      console.log(domTxt);  //输出可以看到vue数据修改后DOM并没有立即更新，后续的dom都不是最新的
      if(domTxt==="原始值"){
        console.log("文本data被修改后dom内容没立即更新");
      }else {
        console.log("文本data被修改后dom内容被马上更新了");
      }
    },
 
  }
}
</script>
 
```

正确的用法是：vue改变dom元素结构后使用vue.$nextTick()方法来实现dom数据更新后延迟执行后续代码

```javascript
changeTxt:function(){
  let that=this;
  that.testMsg="修改后的文本值";  //修改dom结构
   
  that.$nextTick(function(){  //使用vue.$nextTick()方法可以dom数据更新后延迟执行
    let domTxt=document.getElementById('h').innerText; 
    console.log(domTxt);  //输出可以看到vue数据修改后并没有DOM没有立即更新，
    if(domTxt==="原始值"){
      console.log("文本data被修改后dom内容没立即更新");
    }else {
      console.log("文本data被修改后dom内容被马上更新了");
    }
  });
},
```

**==3、==**在使用某个第三方插件时 ，希望在vue生成的某些dom动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。

**待完善........**

 

### Vue.nextTick(callback) 使用原理

原因是，Vue是**==异步执行==**dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个**事件循环 (event loop)** 当中观察到数据变化的 watcher 推送进这个队列。**如果这个watcher被触发多次，只会被推送到队列一次**。等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。**而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。**

当你设置 vm.someData = 'new value'，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。**==如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。(因为这些操作紧跟着写在数据更新后面，会立即执行，可是这时候数据还没有更新，结果就没生效)==**

为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。







## Vuex

state

getter

mutation

action

module

### 举例：dispatch和commit的区别





## vue-router的两种模式

### hash

### history



两种模式的不同：https://blog.csdn.net/qq_34507902/article/details/98849011

vue2笔记中有讲怎样将默认的hash改为history



## vue-router有哪几种导航钩子











## vue2和vue3的区别









## vuecli2和vuecli3的区别











## v-for优先级高于v-if

如果同时出现，每次渲染都会**==先执行循环再判断条件==**，无论如何循环都不可避免，**==浪费了性能==**

要避免出现这种情况，则在**==外层嵌套 template,在这一层进行vi判断==**，然后在内部进行vfor循环







## 响应式的修改数组的值

面vue关于**==数组响应式==**的讲解中提到过，通过**==索引值修改数组元素的方法不是响应式的==**

数组修改要做到响应式，应该用**==Vue.set方法==**或者**==splice方法==**

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\1618109787142.png" alt="1618109787142" style="zoom:80%;" />



同样，想要删除某个属性直接用**==delete 对象.属性==**是删不掉的

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\1618110279350.png" alt="1618110279350" style="zoom:80%;" />

同样需要用到Vue中的方法：**==Vue.delete方法==**

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\1618110494345.png" alt="1618110494345" style="zoom:80%;" />



# ==------------------------------==

# 项目

## 兼容





## 优化

上拉加载添加函数防抖



## 困难











# ==------------------------------==

# 谷歌调试工具

## network使用场景







# ==------------------------------==

# 其他

## 对于代码规范自己的一些见解







## 单页面富应用









## async、await



## 从URI输入网址到页面渲染完成发生了什么









































































熟悉Http协议原理、Web性能优化、常见安全问题及其解决方案







html+css

![image-20210507195802229](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210507195802229.png)

![image-20210507195817459](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210507195817459.png)

![image-20210507195734615](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210507195734615.png)



js

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210507200117772.png" alt="image-20210507200117772" style="zoom:50%;" />

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210507200229324.png" alt="image-20210507200229324" style="zoom:50%;" />

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210507200445456.png" alt="image-20210507200445456" style="zoom:50%;" />

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210507200952031.png" alt="image-20210507200952031" style="zoom:50%;" />

vue

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210507201039809.png" alt="image-20210507201039809" style="zoom:50%;" />

<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210507201126815.png" alt="image-20210507201126815" style="zoom:50%;" />



<img src="C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210507201254330.png" alt="image-20210507201254330" style="zoom:50%;" />







编程题：

![image-20210507201403356](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210507201403356.png)

![image-20210507201437087](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210507201437087.png)















# ==------------------------------==

# 编程题





## 深拷贝、浅拷贝





## 矩阵翻转





## 数的阶乘

```javascript
function jiecheng(num){
    for(var i = num, jc = 1;i > 0;i--){
        jc*=i;
    }
    return jc
}
a = jiecheng(5);
console.log(a)
```





## 冒泡排序



![image-20210512190626513](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210512190626513.png)

**==基本思想：==**

从第一位~倒数第二位，每一位都跟后一位进行比较，一轮结束，最大的元素就会被排到最后面

重复相同的操作，一共进行length-1轮比较

只不过每轮比较时，最大元素都会放在最后面，所以每轮比较的次数会依次递减

```javascript
let arr = [4,8,2,9,4,3,9,7];
//冒泡排序
function bubble(arr){
    // 外层控制需要比较几轮
    for(let i = 0;i < arr.length-1;i++){
        // 内层控制每一轮需要比较几次
        for(let j = 0;j < arr.length-1-i;j++){
            if(arr[j]>arr[j+1]){
                // es6语法，将两个值交换位置
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]]
            }
        }
    }
    return arr
}
console.log(bubble(arr));
```



## 插入排序

![image-20210512194004137](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210512194004137.png)

```javascript
//插入排序
function insert(arr){
    // 创建一个新的数组
    handle = [];
    // 将原数组第一项push进去
    handle.push(arr[0]);
    // 将原数组每一项进行循环，来插入到新数组中
    for(let i = 1; i<arr.length; i++){
        // 和每一个原数组中的数都和新数组进行比较
        for(let j = handle.length; j>=0;j--)
        {
            // 原数组中的元素比新数组当前元素大了，就插入，并退出循环
            if(arr[i]>handle[j]){
                handle.splice(j+1,0,arr[i])
                break;
            }
            //已经比较到第一项，将当前原数组中的数插入到新数组第一项即可
            if(j===0){
                handle.unshift(arr[i])
            }
        }
    }
    return handle
}
console.log(insert(arr));
```

## 快速排序

![image-20210512212856936](C:\Users\无常\AppData\Roaming\Typora\typora-user-images\image-20210512212856936.png)

```javascript
//快速排序
function quick(arr){
    // 先判断是否还需要进行排序，如果长度小于等于1，就不用排序了
    if(arr.length<=1){
        return arr
    }
    // 获取中间索引值
    middleInsert = Math.floor(arr.length/2);
    // 将中间的元素从原数组中删除，原数组改变，并且将删除的中间元素存放起来，作为快排的基准
    middleItem = arr.splice(middleInsert,1)[0]
    // 创建左右两个数组
    let arrLeft = [];
    let arrRight = [];
    // 遍历删除基准后的原数组，比基准小的放左边，大的放右边
    for(let i=0;i<arr.length;i++){
        if(arr[i]<middleItem){
            arrLeft.push(arr[i])
        }
        else{
            arrRight.push(arr[i])
        }
    }
    // 左右两个分数组进行递归，并将返回的结果拼接起来，最后return返回
    return quick(arrLeft).concat(middleItem,quick(arrRight))

}
console.log(`快速排序${quick(arr)}`)
```





## 数组扁平化









## 求数组最大值

在使用Math.max()求数组的最大值时，ES5可以通过 apply 做到（用一种不友好且繁琐的方式）

```js
// ES5 apply 写法
var array = [1,2,3,4,3];
var max1 = Math.max.apply(null,array);
console.log(max1);//4
```

幸运的是JavaScript的世界在不断改变，扩展运算符可用于数组的析构，优雅的解决了这个问题。

```js
// ES6 扩展运算符 写法
var array = [1,2,3,4,3];
var max2 = Math.max(...array);  
console.log(max2);//4
```

先把 array 打散成 1 2 3 4 3，再在里面找最大的那一个，就显而易见了。









































































































